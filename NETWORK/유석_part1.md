## 📚 1. 쿠키와 세션의 차이에 대해 설명해 주세요.
쿠키는 인증 방식은 클라이언트가 서버에 요청을 보내면 서버는 클라이언트의 요청에 대한 응답을 작성할 때, 클라이언트 측에 저장하고 싶은 정보를 응답 헤더의 Set-Cookie에 담습니다. 이후 해당 클라이언트는 요청을 보낼 때마다, 매번 저장된 쿠키를 요청 헤더의 쿠키에 담아 보냅니다. 서버는 쿠키에 담긴 정보를 바탕으로 해당 요청의 클라이언트가 누군지 식별합니다.

하지만 쿠키의 가장 큰 단점으로 보안이 취약하다는 점이고, 용량 제한으로 많은 정보를 담을 수 없을 뿐더러, 웹 브라우저마다 쿠키에 대한 지원 형태가 다르기 대문에 브라우저간 공유가 불가능합니다.

반면에 세션은 쿠키의 보안적 이슈를 해결하고자 클라이언트의 민감한 인증 정보를 브라우저가 아닌 서버 측에 저장하고 관리합니다. 서버의 메모리에 저장하기도 하고, 서버의 로컬 파일이나 데이터베이스에 저장하기도 합니다.

> 1-1. 세션 방식의 로그인 과정에 대해 설명해 주세요.

1. 유저가 웹사이트에서 로그인하면 세션이 서버 메모리 혹은 데이터베이스 상에 저장됩니다. 이때, 세션을 식별하기 위한 Session Id를 기준으로 정보를 저장합니다.
3. 이후 서버에서 브라우저에 쿠키에다가 Session Id를 저장합니다. 
4. 쿠키에 정보가 담겨있기 때문에 브라우저는 해당 사이트에 대한 모든 Request에 Session Id를 쿠키에 담아 전송합니다. 
5. 서버는 클라이언트가 보낸 Session Id와 서버 메모리로 관리하고 있는 Session Id를 비교하여 인증을 수행합니다.

> 1-2. HTTP의 특성인 Stateless에 대해 설명해 주세요.

상태 정보를 유지하지 않는 무상태성 프로토콜이며, 클라이언트와 첫번째 통신에서 데이터를 주고 받았더라도 두 번째 통신에서는 이전 데이터를 유지하지 않고 요청 하나하나를 독립적으로 처리합니다. 따라서 매 요청마다 클라이언트를 식별할 수 있도록 쿠키나 토큰과 같은 인증 정보를 함께 보내야 합니다.

> 1-3. Stateless의 의미를 살펴보면, 세션은 적절하지 않은 인증 방법 아닌가요?

단순히 성질만 비교했을 때 세션은 HTTP의 Stateless 성질과 정반대입니다. 하지만 실제 시스템에서는 불가피하게 필요한 경우가 많기 때문에 사용합니다. 특히 로그인과 같은 것은 사용자의 로그인 여부를 기억해야 하기 때문에 서버가 사용자의 상태 정보를 기억하기 위해 세션을 도입한 것입니다. 그래서 세션은 stateless 특성에는 위배되지만 사용자 경험을 좋게 만들기 위한 방법입니다.

> 1-4. 규모가 커져 서버가 여러 개가 된다면, 세션을 어떻게 관리할 수 있을까요?

기본 세션은 서버 메모리에 저장됩니다. 하지만 서버가 여러 대이면 사용자가 로그인해서 서버 A에 세션이 저장되었고 다음 요청은 서버 B로 가버려서 서버 B는 세션이 없으니 로그인을 하지 않은 것처럼 인식합니다. 그래서 로그인 여부에 대한 서버 간 세션 동기화가 필요합니다. 공유 저장소를 사용하여 모든 서버가 같은 세션 저장소를 보게 하는 방법이 있습니다. 세션을 서버 메모리에 저장하는 대신 DB, Redis와 같은 중앙 저장소에 저장합니다.

또 다른 방법으로는 JWT를 사용하여 세션 없이 서버가 토큰에 대한 검증을 진행하는 방법입니다. 서버가 상태를 안들고 있기 때문에 서버의 개수와 관계 없이 문제 없습니다. 하지만 토큰 자체에 정보가 모두 담기기 때문에 토큰 탈취 위험 등 주의가 필요합니다.

## 📚 2. HTTP 응답코드에 대해 설명해 주세요.
HTTP 응답 상태 코드는 특정 HTTP 요청이 성공적으로 완료되었는지 알려줍니다. 응답은 5개의 그룹으로 나누어집니다: 정보를 제공하는 응답, 성공적인 응답, 리다이렉트, 클라이언트 에러, 그리고 서버 에러가 있습니다.

> 2-1. 401 (Unauthorized) 와 403 (Forbidden)은 의미적으로 어떤 차이가 있나요?

Unauthorized는 클라이언트 요청이 인증이 필요하지만 없거나 유효하지 않거나 실패했을 때 사용됩니다. 이 응답코드는 클라이언트에게 요청된 리소스에 접근하기 위해 자신을 인증해야 한다고 알립니다. Forbidden은 서버가 요청을 이해하고 클라이언트의 신원을 인식했지만 권한 부족으로 액세스를 거부했음을 의미합니다.

> 2-2. 200 (ok) 와 201 (created) 의 차이에 대해 설명해 주세요.

200 ok는 일반적으로 요청을 서버가 처리를 성공적으로 완료했을 때 사용되며, 클라이언트가 요청한 데이터를 담아 보내는 경우가 있습니다. 201 created는 요청을 서버가 성공적으로 처리하였으며, 새로운 resource가 성공적으로 생성되었을 때 사용됩니다. 이에 따라 201 created 응답 코드를 갖는 HTTP Response에 Location이라는 헤더를 추가적으로 설정할 수 있습니다.

## 📚 3. HTTP Method 에 대해 설명해 주세요.
HTTP Method는 클라이언트가 서버에 요청하는 동작의 의도를 나타냅니다. 주요 메서드는 GET, POST, PUT, PATCH, DELETE가 있습니다. 각 메서드는 RESTful 설계 원칙에 따라, 의도에 맞는 메서드를 사용하는것이 서버의 명확성과 일관성을 높이는 데 중요합니다.

> 3-1. HTTP Method의 멱등성에 대해 설명해 주세요.

멱등성(Idempotence)이란, 같은 요청을 여러 번 반복해서 보내더라도 서버의 상태가 처음 요청한 결과와 같아야 한다는 성질을 말합니다. HTTP Method의 멱등성은 요청을 안전하게 재전송하거나, 네트워크 오류 발생 시 자동 재시도를 지원하는 데 중요한 개념입니다. GET, PUT, DELETE는 멱등성을 가지고 POST, PATCH는 멱등성을 가지지 않도록 구현해야 합니다.

> 3-2. GET과 POST의 차이는 무엇인가요?

GET메서드는 서버에 리소스를 '조회'하기 위한 요청입니다. POST메서드는 서버에 '데이터를 생성하거나 변경'하기 위한 요청입니다. 요청데이터의 경우, GET은 URL의 쿼리 스트링에 포함됩니다. POST의 경우 요청 데이터는 HTTP Body에 담겨 전송됩니다. GET은 서버 상태를 변경하지 않고, POST는 서버 상태를 변경합니다. 

**보안 관점**에서 GET은 URL에 데이터가 노출되므로 민감한 데이터 전송에는 POST를 사용합니다. **네트워크 최적화 관점**에서 GET은 캐시할 수 있어 효율적입니다.

> 3-3. POST와 PUT, PATCH의 차이는 무엇인가요?

POST는 서버에 새로운 리소스를 생성하거나 처리를 요청합니다. 메시지 바디를 통해 서버로 요청 데이터를 전달하면 서버는 요청 데이터를 처리하여 업데이트하고 주로 신규 리소스를 등록하거나 프로세스 처리에 사용합니다. 

PUT은 **리소스를 대체(수정)하는 메서드입니다. 만일 요청 메세지에 리소스가 있으면 덮어쓰고, 없으면 새로 생성합니다. 데이터를 대체해야 하기 때문에 POST와 달리 클라이언트가 리소스의 구체적인 전체 경로를 지정해 보내주어야 합니다. 

PATCH는 리소스 일부분을 변경하는 메소드입니다. 변경할 필드만 본문에 포함해 전송하며 일반적으로 멱등성이 보장되지 않지만, 구현에 따라 달라질 수 있습니다.

> 3-4. HTTP 1.1 이후로, GET에도 Body에 데이터를 실을 수 있게 되었습니다. 그럼에도 불구하고 왜 아직도 이런 방식을 지양하는 것일까요?

GET 메서드의 본래 목적은 '리소스 조회'이며, 요청 데이터는 쿼리 스트링을 통해 전달하는 것이 관례입니다. 많은 서버, 프록시, 캐시 시스템들은 GET 요청의 Body를 무시하거나 무시할 수 있다고 가정하고 설계되어 있습니다. 즉, 명확하게 동작이 보장되지 않으며 시스템 호환성과 안정성을 위해 GET에 Body에 데이터를 실는 것을 지양합니다.

## 📚 4. HTTP에 대해 설명해 주세요.
HTTP는 웹 상에서 클라이언트와 서버가 리소스를 주고받기 위해 사용하는 통신 프로토콜입니다. 기본적으로 요청-응답구조를 가지고 있으며, 비연결성과 무상태성을 특징으로 합니다.

> 4-1. 공개키와 대칭키에 대해 설명해 주세요.

대칭키 암호화는하나의 키를 사용해 데이터를 암호화(Encrypt)하고 복호화(Decrypt)합니다. 송신자와 수신자가 **같은 키를 공유**해야 하며, 키를 안전하게 전달하는 것이 중요합니다. 속도가 빠르고 처리량이 높은 장점이 있습니다. 

공개키 암호화는 서로 다른 두 개의 키, 즉 공개키와 개인키를 사용합니다. 공개키로 암호화한 데이터는 개인키로만 복호화할 수 있고, 개인키로 암호화한 데이터는 공개키로만 복호화할 수 있습니다. 공개키는 누구에게나 공개하기 때문에 키 분배가 용이하지만 대칭키 방식에 비해 속도가 느립니다.

> 4-2. 왜 HTTPS Handshake 과정에서는 인증서를 사용하는 것 일까요?

클라이언트가 통신하려는 서버가 '진짜' 신뢰할 수 있는 서버인지 확인하기 위해 필요합니다. 인증서에는 서버의 공개키와 서버 도메인 정보가 담겨 있고, 인증기관(CA, Certificate Authority)의 디지털 서명이 포함되어 있습니다. 클라이언트는 이 서명을 검증해, 중간자 공격(Man-In-The-Middle Attack) 등을 방지할 수 있습니다.

안전한 통신을 위해 클라이언트는 서버의 공개키를 알아야 하는데 Handshake를 통해 인증서 안에 서버의 공개키가 포함되어 있어, 별도로 신뢰할 수 있는 채널 없이 공개키를 안전하게 전달할 수 있습니다.

> 4-3. SSL과 TLS의 차이는 무엇인가요?

TLS는 SSL의 **후속 버전**입니다. SSL 3.0 이후, 보안 취약점 문제를 해결하고 더 강력한 보안을 제공하기 위해 TLS 1.0이 등장했습니다. TLS는 SSL보다 더 안전한 암호화 알고리즘과 핸드셰이크 프로세스를 사용합니다.

TLS는 SSL의 더 안전하고 최신 버전이며, 현재는 TLS만이 표준으로 사용되고 있습니다.

> 4-3. 필요하다면 저희가 직접 응답코드를 정의해서 사용할 수 있을까요? 예를 들어 285번 처럼요.

무작위의 숫자로 정의하면 안됩니다. HTTP 프로토콜 표준에서 100번대부터 500번대까지 이미 정해놨기 때문입니다. 클라이언트는 응답코드를 기준으로 동작을 분기하기 때문에 HTTP 표준에 맞게 사용해야 합니다. 만약 응답에 커스텀이 필요하다면 기존에 있는 응답코드를 사용하고 자체적인 세부 메시지나 body에 추가하여 추가적인 정보를 클라이언트에게 전달할 수 있습니다.

## 📚 5. 웹소켓과 소켓 통신의 차이에 대해 설명해 주세요.
소켓 통신은 TCP나 UDP 같은 프로토콜을 기반으로 동작하는 저수준 통신 방식으로, 서버와 클라이언트 간 데이터를 주고받기 위한 기본적인 인터페이스입니다. 반면, 웹소켓은 웹 환경에서 양방향 통신을 위해 설계된 고수준 프로토콜로, 초기에는 HTTP로 핸드셰이크를 한 뒤 지속적인 TCP 연결을 유지합니다. 또한 소켓은 바이트스트림을 통해 데이터 전송을 하지만 웹소켓의 경우 구조화된 메시지 형식으로 데이터를 다룹니다. 특히 웹소켓은 브라우저와 서버 간에 실시간 통신이 필요한 경우에 적합하며, 대표적으로 채팅 애플리케이션이나 실시간 알림 시스템 등에 활용됩니다.
    
> 5-1. 소켓과 포트의 차이가 무엇인가요?
        
포트는 한 컴퓨터에서 여러 네트워크 애플리케이션을 구분하기 위한 번호입니다. 예를 들어, 80번 포트는 HTTP 서버를 의미하고, 443번은 HTTPS를 의미합니다. 반면, 소켓은 IP 주소와 포트 번호를 결합한 개념으로, 실제 네트워크 통신을 위한 엔드포인트 역할을 합니다. 따라서 소켓은 통신을 가능하게 해주는 도구이고, 포트는 그 통신 대상 애플리케이션을 식별하는 수단이라고 이해하고 있습니다.
        
> 5-1. 여러 소켓이 있다고 할 때, 그 소켓의 포트 번호는 모두 다른가요?
        
소켓은 일반적으로 IP 주소와 포트 번호의 조합으로 구성되며, TCP 통신에서는 클라이언트와 서버 간의 연결을 (클라이언트 IP, 클라이언트 포트, 서버 IP, 서버 포트)로 식별합니다. 서버는 하나의 포트를 열어두고 클라이언트 연결이 들어올 때마다 새로운 커넥션 소켓을 생성하는데, 이때 서버 포트는 동일하지만 클라이언트의 IP와 포트가 달라서 각각의 연결이 구분됩니다. 반대로 클라이언트 입장에서는 여러 소켓을 만들 경우 각기 다른 포트 번호가 사용될 수 있습니다. 따라서 소켓마다 포트가 반드시 다르다고 단정지을 수는 없고, 연결을 구성하는 전체 정보가 소켓을 구분하는 기준이라고 보는 것이 맞습니다.
        
> 5-2. 사용자의 요청이 무수히 많아지면, 소켓도 무수히 생성되나요?
        
TCP 통신에서는 클라이언트가 서버에 접속할 때마다 새로운 커넥션 소켓이 생성됩니다. 서버는 기본적으로 리스닝 소켓 하나만 가지고 있다가, 클라이언트 요청을 수락하면서 각각의 요청에 대해 새로운 소켓을 만들어 통신을 이어갑니다. 따라서 사용자의 요청이 많아지면 소켓도 많아지지만 무수히 생성되면 성능적 이슈가 발생하기 때문에 커넥션 풀을 활용하여 동시에 처리하는 소켓 수에 제한을 두거나 비동기 처리, 웹소켓 재사용 등 다양한 방식으로 효율적으로 관리하는 것이 중요하다고 생각합니다.

## 📚 6. HTTP/1.1과 HTTP/2의 차이점은 무엇인가요?**    
HTTP/1.1과 HTTP/2의 주요 차이점은 성능 최적화와 효율성에 있습니다. HTTP/1.1에서는 요청마다 헤더 정보가 반복되기 때문에 데이터가 비효율적으로 전송되고, 하나의 연결에서 한 번에 하나의 요청만 처리할 수 있어 다수의 요청이 있을 경우 성능 저하가 발생합니다. 반면 HTTP/2는 헤더 압축을 통해 데이터 전송을 최적화하고, 멀티플렉싱을 통해 하나의 연결에서 여러 요청을 동시에 처리할 수 있어 성능이 크게 향상됩니다. 또한 HTTP/2는 서버 푸시 기능을 제공하여 클라이언트가 요청할 가능성이 있는 자원을 미리 전송할 수 있어 페이지 로딩 속도를 줄이는 데 도움을 줍니다.
    
> 6-1. HOL Blocking 에 대해 설명해 주세요.
        
HOL Blocking은 HTTP와 TCP에서 발생하는 방식이 다릅니다. **HTTP**에서 HOL Blocking은 주로 요청을 순차적으로 처리하는 **HTTP/1.x**의 특성 때문에 발생합니다. 클라이언트가 여러 리소스를 요청할 때 첫 번째 요청이 지연되면, 뒤따르는 요청들도 모두 지연되는 문제가 생깁니다. **HTTP/2**에서는 멀티플렉싱을 통해 이 문제를 해결했지만, 여전히 **HTTP/1.x**에서는 이 문제가 존재합니다. 반면, **TCP**에서는 패킷 순서 보장 때문에 하나의 패킷이 손실되거나 지연되면 뒤에 오는 패킷들도 대기하게 되는 **Head-of-Line Blocking** 문제가 발생할 수 있습니다. 이를 해결하려면 패킷 전송 최적화나 UDP와 같은 다른 프로토콜을 고려할 수 있지만, **순서 보장**이 필요하지 않은 경우에 한정됩니다.
        
> 6-2. HTTP/3.0의 주요 특징에 대해 설명해 주세요.
        
HTTP/3는 **QUIC 프로토콜**을 기반으로 하는 차세대 웹 프로토콜로, **TCP**의 단점을 극복하고 성능을 크게 향상시켰습니다. HTTP/3의 주요 특징은 **0-RTT 연결**을 통해 빠른 연결 설정과 재연결을 지원하며, **패킷 손실 시 다른 스트림에 영향을 주지 않**는 멀티플렉싱 기능을 제공합니다. 또한, **TLS 1.3**을 내장하여 보안이 강화된 상태에서 연결을 설정할 수 있습니다.
        
## 📚 **7. TCP와 UDP의 차이에 대해 설명해 주세요.**
    
TCP는 연결형 서비스고, 전송 순서 보장, 수신 여부를 확인합니다. 그리고 1:1 통신을 하며 3-way 핸드쉐이크 과정을 거쳐 신뢰성이 높지만 데이터 순서를 보장하는 등 여러 오버헤드로 인해 속도가 느린 편입니다. UDP는 비연결형 서비스이며, 전송 순서가 바뀔 수 있고, 수신 여부를 확인하지 않습니다. 그리고 1:1, 1:N, N:N 통신이 가능하고 연결을 설정하고 해제하는 과정이 없어 속도는 빠르지만 신뢰성이 낮습니다.
    
> 7-1. Checksum이 무엇인가요?
        
Checksum은 데이터의 무결성을 확인하는 방법으로, 데이터를 전송하거나 저장할 때 발생할 수 있는 오류를 감지하기 위해 사용됩니다. 기본적으로 체크섬은 데이터에 특정 알고리즘을 적용하여 고유한 값을 생성하고, 이를 통해 데이터가 전송 도중이나 저장 중에 변경되었는지 확인할 수 있습니다. 예를 들어, 네트워크 통신에서 체크섬을 사용하여 패킷 손실이나 오류를 검출하고, 파일 다운로드 후 체크섬을 비교하여 무결성을 검사할 수 있습니다. 대표적인 체크섬 알고리즘으로는 **CRC**, **MD5**, **SHA**가 있습니다. 
        
> 7-2. TCP와 UDP 중 어느 프로토콜이 Checksum을 수행할까요?
        
TCP와 UDP 모두 **Checksum**을 사용하여 데이터의 무결성을 확인합니다. **TCP**는 연결 지향형 프로토콜로, 데이터의 무결성을 확인하기 위해 항상 체크섬을 사용하며, 체크섬이 일치하지 않으면 패킷을 폐기하고 재전송을 요청하여 신뢰성 있는 전송을 보장합니다. 반면에, **UDP**는 비연결형 프로토콜로, 체크섬을 사용하여 전송 중 데이터가 손상되었는지 확인합니다. UDP에서 체크섬은 **옵션**일 수 있지만, **IPv6에서는 필수**로 적용됩니다. UDP는 오류 검출만 할 뿐, 재전송 등의 신뢰성 보장을 제공하지 않습니다.
        
> 7-3. 그렇다면, Checksum을 통해 오류를 정정할 수 있나요?
        
Checksum은 데이터의 오류를 **검출**하는 기능만을 제공합니다. 데이터가 전송될 때 체크섬을 계산하여 손상되었는지 확인하고, 만약 불일치가 발생하면 오류를 감지할 수 있습니다. 그러나 체크섬은 오류를 **자동으로 정정**하지 않으며, 오류를 발견하면 이를 **폐기하거나 재전송** 요청을 합니다.
        
> 7-4. TCP가 신뢰성을 보장하는 방법에 대해 설명해 주세요.
        
TCP는 신뢰성 있는 데이터 전송을 보장하기 위해 여러 가지 메커니즘을 사용합니다. 첫째, **순차적 데이터 전송**을 통해 수신 측에서 데이터를 올바른 순서대로 처리할 수 있도록 합니다. 둘째, **체크섬**을 사용하여 데이터의 무결성을 검증하고, 오류가 발생하면 **재전송**을 요청하여 정확한 데이터 전송을 보장합니다. 셋째, **흐름 제어**를 통해 송신자가 수신자가 처리할 수 있는 범위 내에서만 데이터를 전송하고, 네트워크 혼잡을 피하기 위해 **혼잡 제어** 알고리즘을 사용합니다. 마지막으로, 연결 종료 시 **4-way 핸드쉐이크** 과정을 통해 정확하게 연결을 종료하여 데이터 손실 없이 통신을 마칩니다. 이러한 방식으로 TCP는 **신뢰성 있는 데이터 전송**을 제공합니다.
        
> 7-5. TCP의 혼잡 제어 처리 방법에 대해 설명해 주세요.
        
TCP의 혼잡 제어는 네트워크에서 발생할 수 있는 과부하와 패킷 손실을 방지하기 위해 여러 가지 메커니즘을 사용합니다. 첫 번째로, **슬로우 스타트**에서 시작해 네트워크 상태를 점진적으로 파악하며 전송 속도를 증가시킵니다. **혼잡 회피** 단계에서는 선형적으로 전송 속도를 증가시키며 과도한 혼잡을 피합니다. 또한, **빠른 재전송**과 **빠른 회복**을 통해 패킷 손실을 빠르게 감지하고, 데이터의 재전송을 통해 손실을 최소화합니다. 마지막으로, **혼잡 윈도우** 크기를 동적으로 조정하여 네트워크 혼잡 상황에서 전송 속도를 조절함으로써 안정적이고 신뢰성 있는 데이터 전송을 보장합니다.
        
> 7-6. 왜 HTTP는 TCP를 사용하나요?
        
HTTP는 TCP 위에서 동작하는 애플리케이션 계층 프로토콜입니다. 그 이유는 HTTP가 신뢰성 있는 데이터 전송을 요구하기 때문입니다. TCP는 **3-way handshake**를 통해 안정적으로 연결을 설정하고, **흐름 제어**와 **혼잡 제어**를 통해 데이터 전송 속도를 조절하여 과부하를 방지합니다. 또한, TCP는 **순서 보장**과 **재전송** 기능을 제공하여 HTTP에서 전송되는 데이터가 정확하게 도달할 수 있도록 보장합니다. 이 모든 특성 덕분에 HTTP는 TCP의 신뢰성, 연결 지향적인 특성, 흐름 제어 등을 활용하여 안정적인 데이터 전송을 보장할 수 있습니다.
        
> 7-7. 그렇다면, 왜 HTTP/3 에서는 UDP를 사용하나요? 위에서 언급한 UDP의 문제가 해결되었나요?
        
HTTP/3는 **QUIC** 프로토콜을 사용하여 UDP 위에서 동작합니다. 그 이유는 **TCP**에 비해 UDP가 제공하는 **낮은 지연 시간**과 **빠른 연결 설정**을 활용하기 위해서입니다. QUIC은 UDP의 신뢰성 부족 문제를 해결하고, **패킷 손실 복구**, **순서 보장**, **멀티플렉싱** 등을 통해 HTTP/2에서 발생했던 **HOL Blocking** 문제를 해결합니다. 또한, QUIC은 **0-RTT**와 **1-RTT** 연결 설정을 지원하여 HTTP 요청의 지연 시간을 크게 줄이며, **암호화**와 **보안**을 기본적으로 제공하는 특징이 있습니다.
        
> 7-8. 그런데, 브라우저는 어떤 서버가 TCP를 쓰는지 UDP를 쓰는지 어떻게 알 수 있나요?
        
브라우저는 DNS를 통해 해당 서버가 HTTP/3을 지원하는지 확인합니다. HTTP/3를 지원하는 경우 UDP로 인식할 수 있고, HTTP/3를 지원하지 않는다면 HTTP/1.1, 2이기 때문에 TCP로 인식할 수 있습니다.
        
> 7-9. 본인이 새로운 통신 프로토콜을 TCP나 UDP를 사용해서 구현한다고 하면, 어떤 기준으로 프로토콜을 선택하시겠어요?
        
새로운 통신 프로토콜을 구현할 때, **TCP**와 **UDP** 중 어떤 것을 선택할지는 주로 애플리케이션의 요구사항과 성능 목표에 따라 달라집니다. **TCP**는 신뢰성 있는 전송, 순서 보장, 흐름 제어 등을 제공하는 반면, **UDP**는 빠른 전송 속도와 낮은 지연 시간, 간단한 연결 방식이 특징입니다. 예를 들어, **웹 서버**나 **파일 전송**과 같은 **신뢰성 있는 전송**이 필요한 경우 **TCP**를 사용하고, **실시간 스트리밍**이나 **온라인 게임**과 같이 **지연 시간을 최소화**하고 **순서가 중요하지 않은 데이터**를 처리할 경우 **UDP**를 사용하는 것이 적합합니다.
