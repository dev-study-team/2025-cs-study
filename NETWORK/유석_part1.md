## 📚 1. 쿠키와 세션의 차이에 대해 설명해 주세요.
쿠키는 인증 방식은 클라이언트가 서버에 요청을 보내면 서버는 클라이언트의 요청에 대한 응답을 작성할 때, 클라이언트 측에 저장하고 싶은 정보를 응답 헤더의 Set-Cookie에 담습니다. 이후 해당 클라이언트는 요청을 보낼 때마다, 매번 저장된 쿠키를 요청 헤더의 쿠키에 담아 보냅니다. 서버는 쿠키에 담긴 정보를 바탕으로 해당 요청의 클라이언트가 누군지 식별합니다.

하지만 쿠키의 가장 큰 단점으로 보안이 취약하다는 점이고, 용량 제한으로 많은 정보를 담을 수 없을 뿐더러, 웹 브라우저마다 쿠키에 대한 지원 형태가 다르기 대문에 브라우저간 공유가 불가능합니다.

반면에 세션은 쿠키의 보안적 이슈를 해결하고자 클라이언트의 민감한 인증 정보를 브라우저가 아닌 서버 측에 저장하고 관리합니다. 서버의 메모리에 저장하기도 하고, 서버의 로컬 파일이나 데이터베이스에 저장하기도 합니다.

> 1-1. 세션 방식의 로그인 과정에 대해 설명해 주세요.

1. 유저가 웹사이트에서 로그인하면 세션이 서버 메모리 혹은 데이터베이스 상에 저장됩니다. 이때, 세션을 식별하기 위한 Session Id를 기준으로 정보를 저장합니다.
3. 이후 서버에서 브라우저에 쿠키에다가 Session Id를 저장합니다. 
4. 쿠키에 정보가 담겨있기 때문에 브라우저는 해당 사이트에 대한 모든 Request에 Session Id를 쿠키에 담아 전송합니다. 
5. 서버는 클라이언트가 보낸 Session Id와 서버 메모리로 관리하고 있는 Session Id를 비교하여 인증을 수행합니다.

> 1-2. HTTP의 특성인 Stateless에 대해 설명해 주세요.

상태 정보를 유지하지 않는 무상태성 프로토콜이며, 클라이언트와 첫번째 통신에서 데이터를 주고 받았더라도 두 번째 통신에서는 이전 데이터를 유지하지 않고 요청 하나하나를 독립적으로 처리합니다. 따라서 매 요청마다 클라이언트를 식별할 수 있도록 쿠키나 토큰과 같은 인증 정보를 함께 보내야 합니다.

> 1-3. Stateless의 의미를 살펴보면, 세션은 적절하지 않은 인증 방법 아닌가요?

단순히 성질만 비교했을 때 세션은 HTTP의 Stateless 성질과 정반대입니다. 하지만 실제 시스템에서는 불가피하게 필요한 경우가 많기 때문에 사용합니다. 특히 로그인과 같은 것은 사용자의 로그인 여부를 기억해야 하기 때문에 서버가 사용자의 상태 정보를 기억하기 위해 세션을 도입한 것입니다. 그래서 세션은 stateless 특성에는 위배되지만 사용자 경험을 좋게 만들기 위한 방법입니다.

> 1-4. 규모가 커져 서버가 여러 개가 된다면, 세션을 어떻게 관리할 수 있을까요?

기본 세션은 서버 메모리에 저장됩니다. 하지만 서버가 여러 대이면 사용자가 로그인해서 서버 A에 세션이 저장되었고 다음 요청은 서버 B로 가버려서 서버 B는 세션이 없으니 로그인을 하지 않은 것처럼 인식합니다. 그래서 로그인 여부에 대한 서버 간 세션 동기화가 필요합니다. 공유 저장소를 사용하여 모든 서버가 같은 세션 저장소를 보게 하는 방법이 있습니다. 세션을 서버 메모리에 저장하는 대신 DB, Redis와 같은 중앙 저장소에 저장합니다.

또 다른 방법으로는 JWT를 사용하여 세션 없이 서버가 토큰에 대한 검증을 진행하는 방법입니다. 서버가 상태를 안들고 있기 때문에 서버의 개수와 관계 없이 문제 없습니다. 하지만 토큰 자체에 정보가 모두 담기기 때문에 토큰 탈취 위험 등 주의가 필요합니다.

## 📚 2. HTTP 응답코드에 대해 설명해 주세요.
HTTP 응답 상태 코드는 특정 HTTP 요청이 성공적으로 완료되었는지 알려줍니다. 응답은 5개의 그룹으로 나누어집니다: 정보를 제공하는 응답, 성공적인 응답, 리다이렉트, 클라이언트 에러, 그리고 서버 에러가 있습니다.

> 2-1. 401 (Unauthorized) 와 403 (Forbidden)은 의미적으로 어떤 차이가 있나요?

Unauthorized는 클라이언트 요청이 인증이 필요하지만 없거나 유효하지 않거나 실패했을 때 사용됩니다. 이 응답코드는 클라이언트에게 요청된 리소스에 접근하기 위해 자신을 인증해야 한다고 알립니다. Forbidden은 서버가 요청을 이해하고 클라이언트의 신원을 인식했지만 권한 부족으로 액세스를 거부했음을 의미합니다.

> 2-2. 200 (ok) 와 201 (created) 의 차이에 대해 설명해 주세요.

200 ok는 일반적으로 요청을 서버가 처리를 성공적으로 완료했을 때 사용되며, 클라이언트가 요청한 데이터를 담아 보내는 경우가 있습니다. 201 created는 요청을 서버가 성공적으로 처리하였으며, 새로운 resource가 성공적으로 생성되었을 때 사용됩니다. 이에 따라 201 created 응답 코드를 갖는 HTTP Response에 Location이라는 헤더를 추가적으로 설정할 수 있습니다.

> 2-3. 필요하다면 저희가 직접 응답코드를 정의해서 사용할 수 있을까요? 예를 들어 285번 처럼요.

무작위의 숫자로 정의하면 안됩니다. HTTP 프로토콜 표준에서 100번대부터 500번대까지 이미 정해놨기 때문입니다. 클라이언트는 응답코드를 기준으로 동작을 분기하기 때문에 HTTP 표준에 맞게 사용해야 합니다. 만약 응답에 커스텀이 필요하다면 기존에 있는 응답코드를 사용하고 자체적인 세부 메시지나 body에 추가하여 추가적인 정보를 클라이언트에게 전달할 수 있습니다.
