## 📚 1. 쿠키와 세션의 차이에 대해 설명해 주세요.
쿠키는 인증 방식은 클라이언트가 서버에 요청을 보내면 서버는 클라이언트의 요청에 대한 응답을 작성할 때, 클라이언트 측에 저장하고 싶은 정보를 응답 헤더의 Set-Cookie에 담습니다. 이후 해당 클라이언트는 요청을 보낼 때마다, 매번 저장된 쿠키를 요청 헤더의 쿠키에 담아 보냅니다. 서버는 쿠키에 담긴 정보를 바탕으로 해당 요청의 클라이언트가 누군지 식별합니다.

하지만 쿠키의 가장 큰 단점으로 보안이 취약하다는 점이고, 용량 제한으로 많은 정보를 담을 수 없을 뿐더러, 웹 브라우저마다 쿠키에 대한 지원 형태가 다르기 대문에 브라우저간 공유가 불가능합니다.

반면에 세션은 쿠키의 보안적 이슈를 해결하고자 클라이언트의 민감한 인증 정보를 브라우저가 아닌 서버 측에 저장하고 관리합니다. 서버의 메모리에 저장하기도 하고, 서버의 로컬 파일이나 데이터베이스에 저장하기도 합니다.

> 1-1. 세션 방식의 로그인 과정에 대해 설명해 주세요.

1. 유저가 웹사이트에서 로그인하면 세션이 서버 메모리 혹은 데이터베이스 상에 저장됩니다. 이때, 세션을 식별하기 위한 Session Id를 기준으로 정보를 저장합니다.
3. 이후 서버에서 브라우저에 쿠키에다가 Session Id를 저장합니다. 
4. 쿠키에 정보가 담겨있기 때문에 브라우저는 해당 사이트에 대한 모든 Request에 Session Id를 쿠키에 담아 전송합니다. 
5. 서버는 클라이언트가 보낸 Session Id와 서버 메모리로 관리하고 있는 Session Id를 비교하여 인증을 수행합니다.

> 1-2. HTTP의 특성인 Stateless에 대해 설명해 주세요.

상태 정보를 유지하지 않는 무상태성 프로토콜이며, 클라이언트와 첫번째 통신에서 데이터를 주고 받았더라도 두 번째 통신에서는 이전 데이터를 유지하지 않고 요청 하나하나를 독립적으로 처리합니다. 따라서 매 요청마다 클라이언트를 식별할 수 있도록 쿠키나 토큰과 같은 인증 정보를 함께 보내야 합니다.

> 1-3. Stateless의 의미를 살펴보면, 세션은 적절하지 않은 인증 방법 아닌가요?

단순히 성질만 비교했을 때 세션은 HTTP의 Stateless 성질과 정반대입니다. 하지만 실제 시스템에서는 불가피하게 필요한 경우가 많기 때문에 사용합니다. 특히 로그인과 같은 것은 사용자의 로그인 여부를 기억해야 하기 때문에 서버가 사용자의 상태 정보를 기억하기 위해 세션을 도입한 것입니다. 그래서 세션은 stateless 특성에는 위배되지만 사용자 경험을 좋게 만들기 위한 방법입니다.

> 1-4. 규모가 커져 서버가 여러 개가 된다면, 세션을 어떻게 관리할 수 있을까요?

기본 세션은 서버 메모리에 저장됩니다. 하지만 서버가 여러 대이면 사용자가 로그인해서 서버 A에 세션이 저장되었고 다음 요청은 서버 B로 가버려서 서버 B는 세션이 없으니 로그인을 하지 않은 것처럼 인식합니다. 그래서 로그인 여부에 대한 서버 간 세션 동기화가 필요합니다. 공유 저장소를 사용하여 모든 서버가 같은 세션 저장소를 보게 하는 방법이 있습니다. 세션을 서버 메모리에 저장하는 대신 DB, Redis와 같은 중앙 저장소에 저장합니다.

또 다른 방법으로는 JWT를 사용하여 세션 없이 서버가 토큰에 대한 검증을 진행하는 방법입니다. 서버가 상태를 안들고 있기 때문에 서버의 개수와 관계 없이 문제 없습니다. 하지만 토큰 자체에 정보가 모두 담기기 때문에 토큰 탈취 위험 등 주의가 필요합니다.

## 📚 2. HTTP 응답코드에 대해 설명해 주세요.
HTTP 응답 상태 코드는 특정 HTTP 요청이 성공적으로 완료되었는지 알려줍니다. 응답은 5개의 그룹으로 나누어집니다: 정보를 제공하는 응답, 성공적인 응답, 리다이렉트, 클라이언트 에러, 그리고 서버 에러가 있습니다.

> 2-1. 401 (Unauthorized) 와 403 (Forbidden)은 의미적으로 어떤 차이가 있나요?

Unauthorized는 클라이언트 요청이 인증이 필요하지만 없거나 유효하지 않거나 실패했을 때 사용됩니다. 이 응답코드는 클라이언트에게 요청된 리소스에 접근하기 위해 자신을 인증해야 한다고 알립니다. Forbidden은 서버가 요청을 이해하고 클라이언트의 신원을 인식했지만 권한 부족으로 액세스를 거부했음을 의미합니다.

> 2-2. 200 (ok) 와 201 (created) 의 차이에 대해 설명해 주세요.

200 ok는 일반적으로 요청을 서버가 처리를 성공적으로 완료했을 때 사용되며, 클라이언트가 요청한 데이터를 담아 보내는 경우가 있습니다. 201 created는 요청을 서버가 성공적으로 처리하였으며, 새로운 resource가 성공적으로 생성되었을 때 사용됩니다. 이에 따라 201 created 응답 코드를 갖는 HTTP Response에 Location이라는 헤더를 추가적으로 설정할 수 있습니다.

## 📚 3. HTTP Method 에 대해 설명해 주세요.
HTTP Method는 클라이언트가 서버에 요청하는 동작의 의도를 나타냅니다. 주요 메서드는 GET, POST, PUT, PATCH, DELETE가 있습니다. 각 메서드는 RESTful 설계 원칙에 따라, 의도에 맞는 메서드를 사용하는것이 서버의 명확성과 일관성을 높이는 데 중요합니다.

> 3-1. HTTP Method의 멱등성에 대해 설명해 주세요.

멱등성(Idempotence)이란, 같은 요청을 여러 번 반복해서 보내더라도 서버의 상태가 처음 요청한 결과와 같아야 한다는 성질을 말합니다. HTTP Method의 멱등성은 요청을 안전하게 재전송하거나, 네트워크 오류 발생 시 자동 재시도를 지원하는 데 중요한 개념입니다. GET, PUT, DELETE는 멱등성을 가지고 POST, PATCH는 멱등성을 가지지 않도록 구현해야 합니다.

> 3-2. GET과 POST의 차이는 무엇인가요?

GET메서드는 서버에 리소스를 '조회'하기 위한 요청입니다. POST메서드는 서버에 '데이터를 생성하거나 변경'하기 위한 요청입니다. 요청데이터의 경우, GET은 URL의 쿼리 스트링에 포함됩니다. POST의 경우 요청 데이터는 HTTP Body에 담겨 전송됩니다. GET은 서버 상태를 변경하지 않고, POST는 서버 상태를 변경합니다. 

**보안 관점**에서 GET은 URL에 데이터가 노출되므로 민감한 데이터 전송에는 POST를 사용합니다. **네트워크 최적화 관점**에서 GET은 캐시할 수 있어 효율적입니다.

> 3-3. POST와 PUT, PATCH의 차이는 무엇인가요?

POST는 서버에 새로운 리소스를 생성하거나 처리를 요청합니다. 메시지 바디를 통해 서버로 요청 데이터를 전달하면 서버는 요청 데이터를 처리하여 업데이트하고 주로 신규 리소스를 등록하거나 프로세스 처리에 사용합니다. 

PUT은 **리소스를 대체(수정)하는 메서드입니다. 만일 요청 메세지에 리소스가 있으면 덮어쓰고, 없으면 새로 생성합니다. 데이터를 대체해야 하기 때문에 POST와 달리 클라이언트가 리소스의 구체적인 전체 경로를 지정해 보내주어야 합니다. 

PATCH는 리소스 일부분을 변경하는 메소드입니다. 변경할 필드만 본문에 포함해 전송하며 일반적으로 멱등성이 보장되지 않지만, 구현에 따라 달라질 수 있습니다.

> 3-4. HTTP 1.1 이후로, GET에도 Body에 데이터를 실을 수 있게 되었습니다. 그럼에도 불구하고 왜 아직도 이런 방식을 지양하는 것일까요?

GET 메서드의 본래 목적은 '리소스 조회'이며, 요청 데이터는 쿼리 스트링을 통해 전달하는 것이 관례입니다. 많은 서버, 프록시, 캐시 시스템들은 GET 요청의 Body를 무시하거나 무시할 수 있다고 가정하고 설계되어 있습니다. 즉, 명확하게 동작이 보장되지 않으며 시스템 호환성과 안정성을 위해 GET에 Body에 데이터를 실는 것을 지양합니다.

## 📚 4. HTTP에 대해 설명해 주세요.
HTTP는 웹 상에서 클라이언트와 서버가 리소스를 주고받기 위해 사용하는 통신 프로토콜입니다. 기본적으로 요청-응답구조를 가지고 있으며, 비연결성과 무상태성을 특징으로 합니다.

> 4-1. 공개키와 대칭키에 대해 설명해 주세요.

대칭키 암호화는하나의 키를 사용해 데이터를 암호화(Encrypt)하고 복호화(Decrypt)합니다. 송신자와 수신자가 **같은 키를 공유**해야 하며, 키를 안전하게 전달하는 것이 중요합니다. 속도가 빠르고 처리량이 높은 장점이 있습니다. 

공개키 암호화는 서로 다른 두 개의 키, 즉 공개키와 개인키를 사용합니다. 공개키로 암호화한 데이터는 개인키로만 복호화할 수 있고, 개인키로 암호화한 데이터는 공개키로만 복호화할 수 있습니다. 공개키는 누구에게나 공개하기 때문에 키 분배가 용이하지만 대칭키 방식에 비해 속도가 느립니다.

> 4-2. 왜 HTTPS Handshake 과정에서는 인증서를 사용하는 것 일까요?

클라이언트가 통신하려는 서버가 '진짜' 신뢰할 수 있는 서버인지 확인하기 위해 필요합니다. 인증서에는 서버의 공개키와 서버 도메인 정보가 담겨 있고, 인증기관(CA, Certificate Authority)의 디지털 서명이 포함되어 있습니다. 클라이언트는 이 서명을 검증해, 중간자 공격(Man-In-The-Middle Attack) 등을 방지할 수 있습니다.

안전한 통신을 위해 클라이언트는 서버의 공개키를 알아야 하는데 Handshake를 통해 인증서 안에 서버의 공개키가 포함되어 있어, 별도로 신뢰할 수 있는 채널 없이 공개키를 안전하게 전달할 수 있습니다.

> 4-3. SSL과 TLS의 차이는 무엇인가요?

TLS는 SSL의 **후속 버전**입니다. SSL 3.0 이후, 보안 취약점 문제를 해결하고 더 강력한 보안을 제공하기 위해 TLS 1.0이 등장했습니다. TLS는 SSL보다 더 안전한 암호화 알고리즘과 핸드셰이크 프로세스를 사용합니다.

TLS는 SSL의 더 안전하고 최신 버전이며, 현재는 TLS만이 표준으로 사용되고 있습니다.

> 2-3. 필요하다면 저희가 직접 응답코드를 정의해서 사용할 수 있을까요? 예를 들어 285번 처럼요.

무작위의 숫자로 정의하면 안됩니다. HTTP 프로토콜 표준에서 100번대부터 500번대까지 이미 정해놨기 때문입니다. 클라이언트는 응답코드를 기준으로 동작을 분기하기 때문에 HTTP 표준에 맞게 사용해야 합니다. 만약 응답에 커스텀이 필요하다면 기존에 있는 응답코드를 사용하고 자체적인 세부 메시지나 body에 추가하여 추가적인 정보를 클라이언트에게 전달할 수 있습니다.
