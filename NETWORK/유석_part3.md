## 📚 **15. SOP 정책에 대해 설명해 주세요.**
    
동일 출처 정책으로, 한 Origin에서 로드된 문서 또는 스크립트가 다른 Origin의 리소스와 상호작용할 수 있는 방법을 제한하는 중요한 보안 매커니즘입니다. SOP 정책이 없는 경우에는 악의적인 JS 스크립트가 실행되어 접속하려는 포털 사이트에서 응답을 받아 개인정보를 탈취될 수 있습니다. 다시 말해, 웹 브라우저에서 동작하는 프로그램은 로딩된 위치에 있는 리소스만 접근할 수 있다는 정책이다.
    
> 15-1. CORS 정책이 무엇인가요?
        
교차 출처 리소스를 공유할 수 있도록 허용하는 정책입니다. 예전에는 모든 처리를 같은 도메인에서 진행했지만 시간이 지나 현대에는 클라이언트와 서버를 분리하여 API를 직접 호출하는 방식이 당연해지면서 도메인의 차이가 있어 원활하게 요청과 응답을 주고 받기 위해 다른 도메인이지만 리소스를 호출할 수 있도록 CORS 정책이 생기게 되었습니다.
        
> 15-2. Preflight에 대해 설명해 주세요.
        
CORS의 동작원리 중 하나인 Preflight는 Simple Request와 달리, 지금 보내는 요청이 유효한지를 확인하기 위해 OPTIONS 메서드로 예비 요청을 보내는 것입니다. 이렇게 하는 이유는 요청 데이터의 크기가 큰 경우에 무작정 요청을 보내는 경우에 유효하지 않은 요청이라면 불필요하게 많은 리소스를 낭비하고 서버에 부하가 생깁니다. 이러한 오버헤드를 방지하기 위해 예비 요청을 먼저 보내어 유효한 요청인지 확인하는 요청 방식입니다.
        
## 📚 **16. Stateless와 Connectionless에 대해 설명해 주세요.**
    
Stateless란 서버가 클라이언트의 상태를 저장하지 않는 것을 말합니다. 각 요청을 완전히 독립적으로 처리한다는 의미이니다. 서버에 상태를 저장하지 않으므로 서버 확장에 용이하지만, 클라이언트가 데이터를 추가로 전송해야 한다는 단점이 있습니다.

Connectionless는 클라이언트 요청과 서버 응답 이후에도 연결을 종료합니다. 1시간동안 수천명이 서비스를 사용해도, 실제 서버에서의 동시 처리 요청은 매우 적기 때문에 서버 자원을 효츌적으로 사용하기 위해 TCP 연결을 유지하지 않습니다. 하지만 TCP 연결을 계속 새로 맺어야  해서 3-way handshake에 시간이 많이 소요됩니다.
    
> 16-1. 왜 HTTP는 Stateless 구조를 채택하고 있을까요?
        
서버의 단순성과 확장성을 최대화하기 위해서입니다. Stateless 구조를 사용하면 서버가 사용자의 상태 정보를 저장할 필요가 없어져, 서버 설계가 단순해지고 서버 간에 요청을 자유롭게 분산시킬 수 있습니다. 예를 들어, 대규모 분산 시스템에서 서버를 추가하거나 제거하기에 용이합니다.
        
> 16-2. Connectionless의 논리대로면 성능이 되게 좋지 않을 것으로 보이는데, 해결 방법이 있을까요?
        
Connectionless 방식은 각 요청이 독립적으로 처리되기 때문에 성능 문제가 발생할 수 있습니다. 이를 해결하기 위해 캐싱이나 HTTP Keep-Alive를 사용하여 여러 HTTP 요청이 같은 TCP 연결을 통해 전송될 수 있도록 합니다. 이는 연결 설정과 해제에 소요되는 시간과 리소스를 절약할 수 있습니다.
        
> 16-3. TCP의 keep-alive와 HTTP의 keep-alive의 차이는 무엇인가요?

TCP의 keep-alive는 TCP수준에서 연결이 여전히 활성상태임을 보장하기 위해 주기적으로 keep-alive 패킷을 보내는 기능입니다. 이는 네트워크 단절이나, 비활성 연결을 감지하는 데 사용됩니다.

HTTP의 keep-alive는 HTTP 수준에서 동일한 TCP 연결을 여러 HTTP 요청/응답에 걸쳐 재사용할 수 있도록 하는 기능입니다. 이는 웹 페이지가 여러 리소스를 요청할 때 유용하여 연결 설정과 해제에 따른 오버헤드를 감소시킵니다.
        
## 📚 **17. 라우터 내의 포워딩 과정에 대해 설명해 주세요.**
    
먼저 라우터는 네트워크 인터페이스를 통해 패킷을 수신합니다. 수신한 패킷의 IP 헤더를 분석하여 목적지 IP 주소를 확인합니다. 라우터는 목적지 IP 주소와 일치하는 항목을 찾기 위해 포워딩 테이블을 조회합니다. 이후 포워딩 테이블에 기반하여 패킷을 어떤 인터페이스로 보내야 할지를 결정합니다. 패킷이 결정된 인터페이스를 통해 다음 홉으로 전송됩니다.
    
> 17-1. 라우팅과 포워딩의 차이는 무엇인가요?
        
라우팅은 네트워크 경로를 결정하는 과정입니다. 라우터는 네트워크 상의 여러 가능한 경로 중에서 패킷을 목적지까지 보내기 위해 가장 적합한 경로를 선택하는 것이며, 포워딩은 이렇게 선택된 경로를 통해 실제로 패킷을 전달하는 과정입니다. 또한 라우팅은 놀리적인 결정이 필요하기에 라우터의 소프트웨어에서 실행되고, 포워딩은 라우팅 테이블 기반으로 패킷을 실제 전송하는 작업으로 라우터 하드웨어에서 수행됩니다. 그리고 라우팅은 네트워크 환경이 변화하거나 주기적으로 수행하며, 포워딩은 패킷이 도착할 때마다 실시간으로 수행합니다.
        
> 17-2. 라우팅 알고리즘에 대해 설명해 주세요.
        
라우팅 알고리즘은 네트워크에서 데이터 패킷을 목적지까지 가장 효율적으로 전달하기 위해 최적의 경로를 선택하는 방법 또는 절차를 의미합니다. 

크게 정적 라우팅 알고리즘과 동적 라우팅 알고리즘으로 나뉘는데, 정적 라우팅은 네트워크 관리자가 수동으로 라우팅 테이블에 경로를 설정하는 방식입니다. 경로가 고정되어 있으며, 네트워크 환경이 변하더라도 경로가 자동으로 변경되지 않기 때문에 단순성을 최대화할 수 있지만 네트워크가 변경되면 수동으로 경로 설정을 해야하기 때문에 비효율적일 수 있습니다.

동적 라우팅은 라우터들이 라우팅 프로토콜을 사용하여 서로 정보를 교환하고, 네트워크의 상태에 따라 자동으로 라우팅 테이블을 갱신하는 방식입니다. 네트워크의 변화에 유연하게 대응할 수 있으며, 대규모 네트워크에서 효율적입니다. 다만 복잡도가 높고 라우터 간의 정보 교환으로 오버헤드가 발생할 수 있습니다.
        
> 17-3. 포워딩 테이블의 구조에 대해 설명해 주세요.
        
포워딩 테이블은 네트워크 주소의 범위를 나타내는 넷마스크, 목적지 네트워크 주소, 다음 홉, 패킷을 다음 홉으로 전달하기 위해 사용되는 출력 인터페이스로 구성되어 있습니다.

## 📚 **18. 로드밸런서가 무엇인가요?**
    
로드밸런서는 네트워크 또는 서버에 가해지는 부하 트래픽을 분산시켜주는 기술을 의미합니다.
    
> 18-1. L4 로드밸런서와, L7 로드밸런서의 차이에 대해 설명해 주세요.

L4 로드밸런서는 4계층인 전송 계층을 기반으로 포트 번호를 바탕으로 부하를 분산시키는 로드밸런서를 말합니다. 4계층 이하의 모든 정보를 갖고 있어서 IP주소와 포트번호 등을 밸런싱의 데이터로 활용합니다.

L7 로드밸런서는 7계층인 응용 계층을 기반으로 하기 때문에 HTTP 헤더, 쿠키와 같은 사용자의 요청정보를 기준으로 특정 서버에 대한 부하를 분산시키는 로드밸런서를 말합니다.
        
> 18-2. 로드밸런서 알고리즘에 대해 설명해 주세요.
        
주로 사용되는 알고리즘으로 라운드 로빈 알고리즘이 있습니다. 클라이언트의 요청을 여러 대의 서버에 순차적으로 분배하는 방식으로 추가적인 연산 과정 없이 들어온 요청을 빠르게 서버로 분산하는 것을 목표로 하는 방식입니다. 조금 더 발전된 형태로 가중 라운드 로빈은 서버마다 가중치를 설정하여 가중치가 높은 서버부터 요청을 우선적으로 전달하는 방식입니다. 이 방식은 서버의 스펙을 고려하여 적절하게 트래픽을 분산하기 위함입니다.
        
> 18-3. 로드밸런싱 대상이 되는 장치중 일부 장치가 문제가 생겨 접속이 불가능하다고 가정해 봅시다. 이 경우, 로드밸런서가 해당 장비로 요청을 보내지 않도록 하려면 어떻게 해야 할까요?

로드밸런서가 비정상적인 서버로 트래픽을 보내지 않게 하려면 헬스 체크 기능을 설정해야 합니다. 이는 TCP, HTTP 요청 등을 통해 주기적으로 서버 상태를 확인하고, 문제가 있는 서버는 자동으로 풀에서 제외시켜 고가용성을 유지하는 핵심 기능입니다.
        
> 18-4. 로드밸런서 장치를 사용하지 않고, DNS를 활용해서 유사하게 로드밸런싱을 하는 방법에 대해 설명해 주세요.
        
여러 개의 IP 주소를 하나의 도메인에 등록하고, 클라이언트에게 순차적으로 다른 IP를 반환함으로써 부하를 분산시킬 수 있습니다. 하지만 이 방식은 서버 상태를 반영하지 못하거나, DNS 캐시 문제로 완벽한 로드밸런싱은 어렵기 때문에, 상황에 따라 TTL 설정 조정이나 Failover 가능한 DNS 서비스를 사용하는 것이 바람직합니다.
        
## 📚 **19. 서브넷 마스크와, 게이트웨이에 대해 설명해 주세요.**
    
서브넷 마스크는 IP 주소에서 어느 부분이 네트워크를 식별하고, 어느 부분이 호스트를 식별하는지를 결정하는 값입니다. 예를 들어 `255.255.255.0`이라면, IP 주소의 앞 세 옥텟은 네트워크 주소로 사용되고, 마지막 옥텟이 호스트 주소로 사용됩니다.

반면, 게이트웨이는 내부 네트워크에서 외부 네트워크로 나갈 때 필요한 라우터 주소로, 같은 네트워크에 있지 않은 IP로 통신하려면 게이트웨이를 통해야만 합니다.

이 둘은 밀접한 관계가 있는데, 서브넷 마스크로 자신과 상대방이 같은 네트워크에 있는지 판단하고, 같지 않다면 지정된 게이트웨이로 패킷을 전달하여 외부 통신을 수행합니다.

즉, 서브넷 마스크는 네트워크 범위를 구분하고, 게이트웨이는 범위를 벗어난 요청을 라우팅해주는 핵심 역할을 수행한다고 이해하고 있습니다.
    
> 19-1. NAT에 대해 설명해 주세요.
        
네트워크 주소 변환(network address translation, 줄여서 NAT)은 컴퓨터 네트워킹에서 쓰이는 용어로서, IP패킷의 TCP/UDP 포트 숫자와 소스 및 목적지의IP 주소 등을 재기록하면서 라우터를 통해 네트워크 트래픽을 주고 받는 기술을 말한다. 한 마디로 Network Address인 IP를 변환(Translation)하겠다는 뜻이다.NAT를 이용하는 이유는 대개사설 네트워크(Private Network)에 속한 여러 개의 호스트가 하나의 공인 IP 주소를 사용하여 인터넷에 접속하기 위함이다.
        
> 19-2. 서브넷 마스크의 표현 방식에 대해 설명해 주세요.
        
서브넷 마스크는 크게 두 가지 방식으로 표현됩니다. 첫 번째는 `255.255.255.0`처럼 도트 10진수 방식이고, 두 번째는 `/24`처럼 CIDR 표기법입니다. CIDR 표기법은 서브넷 마스크를 비트 수로 표현한 것으로, 네트워크 범위를 보다 명확하고 간결하게 나타낼 수 있습니다.

예를 들어 `/24`는 상위 24비트가 네트워크를 나타내며, 이는 `255.255.255.0`과 동일한 의미를 가집니다.
        
> 19-3. 그렇다면, 255.0.255.0 같은 꼴의 서브넷 마스크도 가능한가요?

서브넷 마스크는 반드시 연속된 1로 시작하고, 그 이후는 0으로만 구성되어야 합니다. 예를 들어 255.255.255.0처럼 비트가 11111111.11111111.11111111.00000000로 이어지는 것이 유효한 형태입니다.
따라서 255.0.255.0처럼 중간에 0이 껴 있다가 다시 1이 나타나는 형태는 규칙을 위반한 것이며, 유효한 서브넷 마스크가 아닙니다.
