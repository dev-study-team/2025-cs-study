## 📚 **15. SOP 정책에 대해 설명해 주세요.**
    
동일 출처 정책으로, 한 Origin에서 로드된 문서 또는 스크립트가 다른 Origin의 리소스와 상호작용할 수 있는 방법을 제한하는 중요한 보안 매커니즘입니다. SOP 정책이 없는 경우에는 악의적인 JS 스크립트가 실행되어 접속하려는 포털 사이트에서 응답을 받아 개인정보를 탈취될 수 있습니다. 다시 말해, 웹 브라우저에서 동작하는 프로그램은 로딩된 위치에 있는 리소스만 접근할 수 있다는 정책이다.
    
> 15-1. CORS 정책이 무엇인가요?
        
교차 출처 리소스를 공유할 수 있도록 허용하는 정책입니다. 예전에는 모든 처리를 같은 도메인에서 진행했지만 시간이 지나 현대에는 클라이언트와 서버를 분리하여 API를 직접 호출하는 방식이 당연해지면서 도메인의 차이가 있어 원활하게 요청과 응답을 주고 받기 위해 다른 도메인이지만 리소스를 호출할 수 있도록 CORS 정책이 생기게 되었습니다.
        
> 15-2. Preflight에 대해 설명해 주세요.
        
CORS의 동작원리 중 하나인 Preflight는 Simple Request와 달리, 지금 보내는 요청이 유효한지를 확인하기 위해 OPTIONS 메서드로 예비 요청을 보내는 것입니다. 이렇게 하는 이유는 요청 데이터의 크기가 큰 경우에 무작정 요청을 보내는 경우에 유효하지 않은 요청이라면 불필요하게 많은 리소스를 낭비하고 서버에 부하가 생깁니다. 이러한 오버헤드를 방지하기 위해 예비 요청을 먼저 보내어 유효한 요청인지 확인하는 요청 방식입니다.
        
## 📚 **16. Stateless와 Connectionless에 대해 설명해 주세요.**
    
Stateless란 서버가 클라이언트의 상태를 저장하지 않는 것을 말합니다. 각 요청을 완전히 독립적으로 처리한다는 의미이니다. 서버에 상태를 저장하지 않으므로 서버 확장에 용이하지만, 클라이언트가 데이터를 추가로 전송해야 한다는 단점이 있습니다.

Connectionless는 클라이언트 요청과 서버 응답 이후에도 연결을 종료합니다. 1시간동안 수천명이 서비스를 사용해도, 실제 서버에서의 동시 처리 요청은 매우 적기 때문에 서버 자원을 효츌적으로 사용하기 위해 TCP 연결을 유지하지 않습니다. 하지만 TCP 연결을 계속 새로 맺어야  해서 3-way handshake에 시간이 많이 소요됩니다.
    
> 16-1. 왜 HTTP는 Stateless 구조를 채택하고 있을까요?
        
서버의 단순성과 확장성을 최대화하기 위해서입니다. Stateless 구조를 사용하면 서버가 사용자의 상태 정보를 저장할 필요가 없어져, 서버 설계가 단순해지고 서버 간에 요청을 자유롭게 분산시킬 수 있습니다. 예를 들어, 대규모 분산 시스템에서 서버를 추가하거나 제거하기에 용이합니다.
        
> 16-2. Connectionless의 논리대로면 성능이 되게 좋지 않을 것으로 보이는데, 해결 방법이 있을까요?
        
Connectionless 방식은 각 요청이 독립적으로 처리되기 때문에 성능 문제가 발생할 수 있습니다. 이를 해결하기 위해 캐싱이나 HTTP Keep-Alive를 사용하여 여러 HTTP 요청이 같은 TCP 연결을 통해 전송될 수 있도록 합니다. 이는 연결 설정과 해제에 소요되는 시간과 리소스를 절약할 수 있습니다.
        
> 16-3. TCP의 keep-alive와 HTTP의 keep-alive의 차이는 무엇인가요?

TCP의 keep-alive는 TCP수준에서 연결이 여전히 활성상태임을 보장하기 위해 주기적으로 keep-alive 패킷을 보내는 기능입니다. 이는 네트워크 단절이나, 비활성 연결을 감지하는 데 사용됩니다.

HTTP의 keep-alive는 HTTP 수준에서 동일한 TCP 연결을 여러 HTTP 요청/응답에 걸쳐 재사용할 수 있도록 하는 기능입니다. 이는 웹 페이지가 여러 리소스를 요청할 때 유용하여 연결 설정과 해제에 따른 오버헤드를 감소시킵니다.
        
## 📚 **17. 라우터 내의 포워딩 과정에 대해 설명해 주세요.**
    
먼저 라우터는 네트워크 인터페이스를 통해 패킷을 수신합니다. 수신한 패킷의 IP 헤더를 분석하여 목적지 IP 주소를 확인합니다. 라우터는 목적지 IP 주소와 일치하는 항목을 찾기 위해 포워딩 테이블을 조회합니다. 이후 포워딩 테이블에 기반하여 패킷을 어떤 인터페이스로 보내야 할지를 결정합니다. 패킷이 결정된 인터페이스를 통해 다음 홉으로 전송됩니다.
    
> 17-1. 라우팅과 포워딩의 차이는 무엇인가요?
        
라우팅은 네트워크 경로를 결정하는 과정입니다. 라우터는 네트워크 상의 여러 가능한 경로 중에서 패킷을 목적지까지 보내기 위해 가장 적합한 경로를 선택하는 것이며, 포워딩은 이렇게 선택된 경로를 통해 실제로 패킷을 전달하는 과정입니다. 또한 라우팅은 놀리적인 결정이 필요하기에 라우터의 소프트웨어에서 실행되고, 포워딩은 라우팅 테이블 기반으로 패킷을 실제 전송하는 작업으로 라우터 하드웨어에서 수행됩니다. 그리고 라우팅은 네트워크 환경이 변화하거나 주기적으로 수행하며, 포워딩은 패킷이 도착할 때마다 실시간으로 수행합니다.
        
> 17-2. 라우팅 알고리즘에 대해 설명해 주세요.
        
라우팅 알고리즘은 네트워크에서 데이터 패킷을 목적지까지 가장 효율적으로 전달하기 위해 최적의 경로를 선택하는 방법 또는 절차를 의미합니다. 

크게 정적 라우팅 알고리즘과 동적 라우팅 알고리즘으로 나뉘는데, 정적 라우팅은 네트워크 관리자가 수동으로 라우팅 테이블에 경로를 설정하는 방식입니다. 경로가 고정되어 있으며, 네트워크 환경이 변하더라도 경로가 자동으로 변경되지 않기 때문에 단순성을 최대화할 수 있지만 네트워크가 변경되면 수동으로 경로 설정을 해야하기 때문에 비효율적일 수 있습니다.

동적 라우팅은 라우터들이 라우팅 프로토콜을 사용하여 서로 정보를 교환하고, 네트워크의 상태에 따라 자동으로 라우팅 테이블을 갱신하는 방식입니다. 네트워크의 변화에 유연하게 대응할 수 있으며, 대규모 네트워크에서 효율적입니다. 다만 복잡도가 높고 라우터 간의 정보 교환으로 오버헤드가 발생할 수 있습니다.
        
> 17-3. 포워딩 테이블의 구조에 대해 설명해 주세요.
        
포워딩 테이블은 네트워크 주소의 범위를 나타내는 넷마스크, 목적지 네트워크 주소, 다음 홉, 패킷을 다음 홉으로 전달하기 위해 사용되는 출력 인터페이스로 구성되어 있습니다.
