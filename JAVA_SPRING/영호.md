## **1. JVM이 정확히 무엇이고, 어떤 기능을 하는지 설명해 주세요.**

자바 바이트코드를 실행하는 가상 머신. 바이트코드를 해석하고 실행하는 역할. GC를 통해 메모리 관리를 해준다.

클래스 로더 시스템, 런타임 데이터 영역, 실행엔진, 네이티브 메서드 인터페이스로 구성된다.

> 1-1. 그럼, 자바 말고 다른 언어는 JVM 위에 올릴 수 없나요?
> 

JVM 이 해석하는 바이트코드 형태로 전환한다면 모든 언어가 적용가능 하다. 대표적으로 코틀린이 있다.

> 1-2. 반대로 JVM 계열 언어를 일반적으로 컴파일해서 사용할 순 없나요?
> 

GraalVM으로 JVM 계열언어를 네이티브 실행 파일로 컴파일 할 수 있다. 메모리 사용량 감소, 실행 시간 단축등의 장점이 있다. 리플렉션, 동적 클래스 로딩, JIT 동적 최적화 등 JVM 특유의 기능을 사용 할 수 없다.

> 1-3. VM을 사용함으로써 얻을 수 있는 장점과 단점에 대해 설명해 주세요.
> 

장점 : 플랫폼 독립성, 자동 메모리 관리

단점 : native 언어에 비해 속도가 느리고, 메모리 사용량이 많다. 예측하기 힘듬 GC 동작.

> 1-4. JVM과 내부에서 실행되고 있는 프로그램은 부모 프로세스 - 자식 프로세스 관계를 갖고 있다고 봐도 무방한가요?
> 

부모 - 자식 프로세스 관계라기보다 실행환경 - 실행 코드의 관계라고 볼 수 있다.

## **2. final 키워드를 사용하면, 어떤 이점이 있나요?**

변수에 사용되는 경우 primitive 값의 경우 수정이 불가하고, 참조타입 의 경우 재할당이 불가능 하다. 

메서드에 사용되는 경우 하위 클래스에서 오버라이드가 불가능하다.

클래스에서 사용되는 경우, 상속될 수 없다.

> 2-1. 그렇다면 컴파일 과정에서, final 키워드는 다르게 취급되나요?
> 

인라인화, 상수폴딩 등으로 최적화 가능하다. 인라인화 : 변수를 값으로 대체.

상수 폴딩: 컴파일 시점에 알 수 있는 final 상수 값을 사용하는 표현식을 계산하여 최적화.

## **3. 인터페이스와 추상 클래스의 차이에 대해 설명해 주세요.**

추상 클래스 : 한개 이상의

추상 클래스는 모든 종류의 변수를 가질 수 있지만, 인터페이스의 변수는 public static final이어야 함

인터페이스 : 관련 없는 클래스들이 공통 기능을 구현할때, 다중 상속이 필요한 경우.

추상클래스 : 관련 있는 클래스들이 코드 공유하고 싶을때, 하위 클래스들의 공통 기능을 한 곳에서 관리하고 싶을 때

오히려, 잘 모르겠다. 

> 3-1. 왜 클래스는 단일 상속만 가능한데, 인터페이스는 2개 이상 구현이 가능할까요?
> 

단일 상속은 구현의 모호성을 방지하고, 한 클래스가 여러가지 기능을 구현하고 싶을때 사용하라고 존재한다.

## **4. 리플렉션에 대해 설명해 주세요.**

실행 중인 자바 프로그램이 자기 자신의 구조를 검사하고 수정할 수 있게 해주는 자바의 기능.

클래스의 정보를 동적으로 검사할 수 있다. 접근 제어자와 상관없이 클래스의 멤버에 접근할 수 있다.

단점

- 성능 저하: 일반 코드보다 느립니다.
- 보안 위험: 접근 제어를 우회할 수 있습니다.
- 코드 복잡성 증가: 실행 시점에 오류가 발견될 수 있으며 디버깅이 어렵습니다.
- 캡슐화 위반: 객체의 내부 구현에 직접 접근하기 때문에 OOP 원칙을 위반할 수 있습니다.

> 4-1. 의미만 들어보면 리플렉션은 보안적인 문제가 있을 가능성이 있어보이는데, 실제로 그렇게 생각하시나요? 만약 그렇다면, 어떻게 방지할 수 있을까요?
> 

접근 제어 우회가 가능하다. 자바의 SecurityManager를 구성하여 리플렉션 API의 사용을 제한. 접근 제한 검사를 추가하거나 최소한의 영역에서만 사용한다.

> 4-2. 리플렉션을 언제 활용할 수 있을까요?
> 

테스트를 위해 객체의 필드에 특정 값을 세팅해야 할때.

## **5. static class와 static method를 비교해 주세요.**

static class는 inner class 로만 쓰인다.

외부 클래스 인스턴스 생성하지 않고 쓸 수 있다. 외부 클래스와 논리적 그룹핑을 위해 사용.

static method는 인스턴스 생성없이 사용가능.

> 5-1. static 을 사용하면 어떤 이점을 얻을 수 있나요? 어떤 제약이 걸릴까요?
> 

장점

1. 인스턴스화 안해도 되서 메모리 절약, 접근이 용이하다.

단점

1. GC 대상이 되지 않아서 메모리 누수 가능성
2. 동시성 문제 발생 가능성
3. static 메소드에서는 인스턴스 변수 접근이 안된다.
4. 테스트가 어렵다.
    1. 전역객체 라서 테스트 간 격리가 힘듬.
    2. 의존성 주입이 안됨, mock 객체 생성도 힘듬

> 5-2. 컴파일 과정에서 static 이 어떻게 처리되는지 설명해 주세요.
> 

static final 상수는 클래스 파일 상수 풀에 저장된다.

static 초기화 블록은 클래스 로딩될때 JVM 에 의해 실행된다.

static 메소드의 경우 정적 바인딩으로 처리된다.

## **6. Java의 Exception에 대해 설명해 주세요.**

프로그램 실행 중 발생할 수 있는 예외사항을 처리하기 위한 메커니즘입니다.

1. RuntimeException

명시적인 처리가 강제되지 않는다.

1. Checked Exception

컴파일 타임에 해당 예외처리가 되었는지 확인한다.

> 6-1. 예외처리를 하는 세 방법에 대해 설명해 주세요.
> 

try catch, throw, try with resource throw 의 경우 호출자에게 처리를 위임한다.

> 6-2. CheckedException, UncheckedException 의 차이에 대해 설명해 주세요.
> 

> 6-3. 예외처리가 성능에 큰 영향을 미치나요? 만약 그렇다면, 어떻게 하면 부하를 줄일 수 있을까요?
> 

예외가 발생하면 JVM은 전체 호출 스택을 캡처하여 스택 트레이스를 생성합니다. 예외가 발생하는 코드 경로는 JIT 컴파일러에 의해 최적화되기 어렵습니다.

불필요한 예외처리를 하지 않는다 - 흐름제어를 예외처리 메커니즘으로 하지 않는다. 불필요한 스택 트레이스를 하지 않는다. 예외 래핑을 최소화 한다.

## **7. Synchronized 키워드에 대해 설명해 주세요.**

멀티 쓰레드 환경에서 동기화를 위해 사용된다.

> 7-1. Synchronized 키워드가 어디에 붙는지에 따라 의미가 약간씩 변화하는데, 각각 어떤 의미를 갖게 되는지 설명해 주세요.
> 

메서드에 붙일시 메서드 전체가 동기화. synchronized 블럭 사용 - 블럭 내부가 동기화, static 메서드 동기화 - 해당 클래스에 대한 락이 걸림.

> 7-2. 효율적인 코드 작성 측면에서, Synchronized는 좋은 키워드일까요?
> 

상황에 따라 다르다. 간단히 신뢰할 수 있는 동시성 제어를 할 수 있다는 장점이 있다. 다만, 락을 걸기때문에 성능 오버헤드가 있고 데드락 발생 가능성이 존재한다.

> 7-3. Synchronized 를 대체할 수 있는 자바의 다른 동기화 기법에 대해 설명해 주세요.
> 

원자적 연산(Atomic Integer),  Lock 인터페이스 구현체들, Thread Local. 최근에는 Reentrant Lock 이 많이 사용된다.

> 7-4. Thread Local에 대해 설명해 주세요.
> 

각 쓰레드가 자신만의 저장공간을 가짐으로 써 동시성 문제를 해결. 다만, 쓰레드풀 환경에서는 주의가 필요하다.

Spring Security 의 Authentication 정보가 Thread Local 에 사용된다.

## **8. Java Stream에 대해 설명해 주세요.**

Java 8 에서 도입된 기능으로 컬렉션 데이터를 함수형 프로그래밍 방식으로 처리할 수 있게 해주는 도구입니다.

선언적 프로그래밍, 함수형 프로그래밍 패러다임을 지원 합니다. 생성, 중간 연산, 최종 연산 형태로 이루어져 있습니다. 장점으로는 가독성 향상, 병렬 처리 등이 있습니다. 단점으로는 디버깅이 어려울 수 있고, 성능에 저하가 올 수 있습니다.

> 8-1. Stream과 for ~ loop의 성능 차이를 비교해 주세요
> 

데이터가 적은 일반적인 경우에 for loop 이 오버헤드가 적고, JIT 최적화도 잘 일어나기 때문에 더 나은 성능을 봉니다. Stream 의 경우 대용량 데이터에서 parallelStream() 을 사용시 작업이 독립적이고 병렬화에 적합할 경우 for loop 보다 훨씬 빠르다. Stream 의 경우 중간 결과를 메모리에 저장해야 할 수도 있기 때문에 이를 고려해야 한다.

> 8-2. Stream은 병렬처리 할 수 있나요?
> 

ForkJoinPool 프레임워크를 사용하여서 여러 스레드로 분할한다. 데이터를 여러 청크로 나누고 각 청크를 별도 스레드에서 처리후 결과를 병합한다. 각 요소의 처리가 독립적인 경우 적합하다.

> 8-3. Stream에서 사용할 수 있는 함수형 인터페이스에 대해 설명해 주세요.
> 

단 하나의 추상 메서드만을 가지는 인터페이스를 의미한다.

함수형 프로그래밍 이란 Side effect가 없는 순수 함수를 1급 객체로 간주하여, 참조 투명성을 지킬 수 있다.

> 8-4가끔 외부 변수를 사용할 때, final 키워드를 붙여서 사용하는데 왜 그럴까요? 꼭 그래야 할까요?
> 

함수형 프로그래밍의 불변성 원칙을 지키기 위해 final 키워드를 붙이는걸 권장한다. 다만, Java 8 이후로는 effectively final 상태를 유지한다면 꼭 final 키워드를 붙일 필요는 없다. effectively final 이란 선언 이후 값이 변경되지 않는 변수를 의미한다.

## **9. Java의 GC에 대해 설명해 주세요.**

자바 heap 영역에서 참조되지 않고 있는 객체의 메모리를 수거해간다. 이를 통해 개발자는 메모리 관리를 직접 할 필요가 없게 된다. 하지만, 여러 가지 성능 이슈가 gc 때문에 발생할 수 있다. java 8 이후로 g1gc 가 디폴트로 자리잡았다. 자바15 이후로 zgc 가 도입되었다.

> 9-1. finalize() 를 수동으로 호출하는 것은 왜 문제가 될 수 있을까요?
> 

호출하더라도 실제로 gc가 언제 작동할 지는 알 수 없다.

> 9-2. 어떤 변수의 값이 null이 되었다면, 이 값은 GC가 될 가능성이 있을까요?
> 

다른 곳에서 참조 되지 않고 있다면 GC에 의해 수거 될 것이다.