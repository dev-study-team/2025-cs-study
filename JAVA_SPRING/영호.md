## **1. JVM이 정확히 무엇이고, 어떤 기능을 하는지 설명해 주세요.**

자바 바이트코드를 실행하는 가상 머신. 바이트코드를 해석하고 실행하는 역할. GC를 통해 메모리 관리를 해준다.

클래스 로더 시스템, 런타임 데이터 영역, 실행엔진, 네이티브 메서드 인터페이스로 구성된다.

> 1-1. 그럼, 자바 말고 다른 언어는 JVM 위에 올릴 수 없나요?

JVM 이 해석하는 바이트코드 형태로 전환한다면 모든 언어가 적용가능 하다. 대표적으로 코틀린이 있다.

> 1-2. 반대로 JVM 계열 언어를 일반적으로 컴파일해서 사용할 순 없나요?

GraalVM으로 JVM 계열언어를 네이티브 실행 파일로 컴파일 할 수 있다. 메모리 사용량 감소, 실행 시간 단축등의 장점이 있다. 리플렉션, 동적 클래스 로딩, JIT 동적 최적화 등 JVM 특유의 기능을 사용 할 수 없다.

> 1-3. VM을 사용함으로써 얻을 수 있는 장점과 단점에 대해 설명해 주세요.

장점 : 플랫폼 독립성, 자동 메모리 관리

단점 : native 언어에 비해 속도가 느리고, 메모리 사용량이 많다. 예측하기 힘듬 GC 동작.

> 1-4. JVM과 내부에서 실행되고 있는 프로그램은 부모 프로세스 - 자식 프로세스 관계를 갖고 있다고 봐도 무방한가요?

부모 - 자식 프로세스 관계라기보다 실행환경 - 실행 코드의 관계라고 볼 수 있다.

## **2. final 키워드를 사용하면, 어떤 이점이 있나요?**

변수에 사용되는 경우 primitive 값의 경우 수정이 불가하고, 참조타입 의 경우 재할당이 불가능 하다.

메서드에 사용되는 경우 하위 클래스에서 오버라이드가 불가능하다.

클래스에서 사용되는 경우, 상속될 수 없다.

> 2-1. 그렇다면 컴파일 과정에서, final 키워드는 다르게 취급되나요?

인라인화, 상수폴딩 등으로 최적화 가능하다. 인라인화 : 변수를 값으로 대체.

상수 폴딩: 컴파일 시점에 알 수 있는 final 상수 값을 사용하는 표현식을 계산하여 최적화.

## **3. 인터페이스와 추상 클래스의 차이에 대해 설명해 주세요.**

추상 클래스 : 한개 이상의

추상 클래스는 모든 종류의 변수를 가질 수 있지만, 인터페이스의 변수는 public static final이어야 함

인터페이스 : 관련 없는 클래스들이 공통 기능을 구현할때, 다중 상속이 필요한 경우.

추상클래스 : 관련 있는 클래스들이 코드 공유하고 싶을때, 하위 클래스들의 공통 기능을 한 곳에서 관리하고 싶을 때

오히려, 잘 모르겠다.

> 3-1. 왜 클래스는 단일 상속만 가능한데, 인터페이스는 2개 이상 구현이 가능할까요?

단일 상속은 구현의 모호성을 방지하고, 한 클래스가 여러가지 기능을 구현하고 싶을때 사용하라고 존재한다.

## **4. 리플렉션에 대해 설명해 주세요.**

실행 중인 자바 프로그램이 자기 자신의 구조를 검사하고 수정할 수 있게 해주는 자바의 기능.

클래스의 정보를 동적으로 검사할 수 있다. 접근 제어자와 상관없이 클래스의 멤버에 접근할 수 있다.

단점

- 성능 저하: 일반 코드보다 느립니다.
- 보안 위험: 접근 제어를 우회할 수 있습니다.
- 코드 복잡성 증가: 실행 시점에 오류가 발견될 수 있으며 디버깅이 어렵습니다.
- 캡슐화 위반: 객체의 내부 구현에 직접 접근하기 때문에 OOP 원칙을 위반할 수 있습니다.

> 4-1. 의미만 들어보면 리플렉션은 보안적인 문제가 있을 가능성이 있어보이는데, 실제로 그렇게 생각하시나요? 만약 그렇다면, 어떻게 방지할 수 있을까요?

접근 제어 우회가 가능하다. 자바의 SecurityManager를 구성하여 리플렉션 API의 사용을 제한. 접근 제한 검사를 추가하거나 최소한의 영역에서만 사용한다.

> 4-2. 리플렉션을 언제 활용할 수 있을까요?

테스트를 위해 객체의 필드에 특정 값을 세팅해야 할때.

## **5. static class와 static method를 비교해 주세요.**

static class는 inner class 로만 쓰인다.

외부 클래스 인스턴스 생성하지 않고 쓸 수 있다. 외부 클래스와 논리적 그룹핑을 위해 사용.

static method는 인스턴스 생성없이 사용가능.

> 5-1. static 을 사용하면 어떤 이점을 얻을 수 있나요? 어떤 제약이 걸릴까요?

장점

1. 인스턴스화 안해도 되서 메모리 절약, 접근이 용이하다.

단점

1. GC 대상이 되지 않아서 메모리 누수 가능성
2. 동시성 문제 발생 가능성
3. static 메소드에서는 인스턴스 변수 접근이 안된다.
4. 테스트가 어렵다.
   1. 전역객체 라서 테스트 간 격리가 힘듬.
   2. 의존성 주입이 안됨, mock 객체 생성도 힘듬

> 5-2. 컴파일 과정에서 static 이 어떻게 처리되는지 설명해 주세요.

static final 상수는 클래스 파일 상수 풀에 저장된다.

static 초기화 블록은 클래스 로딩될때 JVM 에 의해 실행된다.

static 메소드의 경우 정적 바인딩으로 처리된다.

## **6. Java의 Exception에 대해 설명해 주세요.**

프로그램 실행 중 발생할 수 있는 예외사항을 처리하기 위한 메커니즘입니다.

1. RuntimeException

명시적인 처리가 강제되지 않는다.

1. Checked Exception

컴파일 타임에 해당 예외처리가 되었는지 확인한다.

> 6-1. 예외처리를 하는 세 방법에 대해 설명해 주세요.

try catch, throw, try with resource throw 의 경우 호출자에게 처리를 위임한다.

> 6-2. CheckedException, UncheckedException 의 차이에 대해 설명해 주세요.

> 6-3. 예외처리가 성능에 큰 영향을 미치나요? 만약 그렇다면, 어떻게 하면 부하를 줄일 수 있을까요?

예외가 발생하면 JVM은 전체 호출 스택을 캡처하여 스택 트레이스를 생성합니다. 예외가 발생하는 코드 경로는 JIT 컴파일러에 의해 최적화되기 어렵습니다.

불필요한 예외처리를 하지 않는다 - 흐름제어를 예외처리 메커니즘으로 하지 않는다. 불필요한 스택 트레이스를 하지 않는다. 예외 래핑을 최소화 한다.

## **7. Synchronized 키워드에 대해 설명해 주세요.**

멀티 쓰레드 환경에서 동기화를 위해 사용된다.

> 7-1. Synchronized 키워드가 어디에 붙는지에 따라 의미가 약간씩 변화하는데, 각각 어떤 의미를 갖게 되는지 설명해 주세요.

메서드에 붙일시 메서드 전체가 동기화. synchronized 블럭 사용 - 블럭 내부가 동기화, static 메서드 동기화 - 해당 클래스에 대한 락이 걸림.

> 7-2. 효율적인 코드 작성 측면에서, Synchronized는 좋은 키워드일까요?

상황에 따라 다르다. 간단히 신뢰할 수 있는 동시성 제어를 할 수 있다는 장점이 있다. 다만, 락을 걸기때문에 성능 오버헤드가 있고 데드락 발생 가능성이 존재한다.

> 7-3. Synchronized 를 대체할 수 있는 자바의 다른 동기화 기법에 대해 설명해 주세요.

원자적 연산(Atomic Integer), Lock 인터페이스 구현체들, Thread Local. 최근에는 Reentrant Lock 이 많이 사용된다.

> 7-4. Thread Local에 대해 설명해 주세요.

각 쓰레드가 자신만의 저장공간을 가짐으로 써 동시성 문제를 해결. 다만, 쓰레드풀 환경에서는 주의가 필요하다.

Spring Security 의 Authentication 정보가 Thread Local 에 사용된다.

## **8. Java Stream에 대해 설명해 주세요.**

Java 8 에서 도입된 기능으로 컬렉션 데이터를 함수형 프로그래밍 방식으로 처리할 수 있게 해주는 도구입니다.

선언적 프로그래밍, 함수형 프로그래밍 패러다임을 지원 합니다. 생성, 중간 연산, 최종 연산 형태로 이루어져 있습니다. 장점으로는 가독성 향상, 병렬 처리 등이 있습니다. 단점으로는 디버깅이 어려울 수 있고, 성능에 저하가 올 수 있습니다.

> 8-1. Stream과 for ~ loop의 성능 차이를 비교해 주세요

데이터가 적은 일반적인 경우에 for loop 이 오버헤드가 적고, JIT 최적화도 잘 일어나기 때문에 더 나은 성능을 봉니다. Stream 의 경우 대용량 데이터에서 parallelStream() 을 사용시 작업이 독립적이고 병렬화에 적합할 경우 for loop 보다 훨씬 빠르다. Stream 의 경우 중간 결과를 메모리에 저장해야 할 수도 있기 때문에 이를 고려해야 한다.

> 8-2. Stream은 병렬처리 할 수 있나요?

ForkJoinPool 프레임워크를 사용하여서 여러 스레드로 분할한다. 데이터를 여러 청크로 나누고 각 청크를 별도 스레드에서 처리후 결과를 병합한다. 각 요소의 처리가 독립적인 경우 적합하다.

> 8-3. Stream에서 사용할 수 있는 함수형 인터페이스에 대해 설명해 주세요.

단 하나의 추상 메서드만을 가지는 인터페이스를 의미한다.

함수형 프로그래밍 이란 Side effect가 없는 순수 함수를 1급 객체로 간주하여, 참조 투명성을 지킬 수 있다.

> 8-4가끔 외부 변수를 사용할 때, final 키워드를 붙여서 사용하는데 왜 그럴까요? 꼭 그래야 할까요?

함수형 프로그래밍의 불변성 원칙을 지키기 위해 final 키워드를 붙이는걸 권장한다. 다만, Java 8 이후로는 effectively final 상태를 유지한다면 꼭 final 키워드를 붙일 필요는 없다. effectively final 이란 선언 이후 값이 변경되지 않는 변수를 의미한다.

## **9. Java의 GC에 대해 설명해 주세요.**

자바 heap 영역에서 참조되지 않고 있는 객체의 메모리를 수거해간다. 이를 통해 개발자는 메모리 관리를 직접 할 필요가 없게 된다. 하지만, 여러 가지 성능 이슈가 gc 때문에 발생할 수 있다. java 8 이후로 g1gc 가 디폴트로 자리잡았다. 자바15 이후로 zgc 가 도입되었다.

> 9-1. finalize() 를 수동으로 호출하는 것은 왜 문제가 될 수 있을까요?

호출하더라도 실제로 gc가 언제 작동할 지는 알 수 없다.

> 9-2. 어떤 변수의 값이 null이 되었다면, 이 값은 GC가 될 가능성이 있을까요?

다른 곳에서 참조 되지 않고 있다면 GC에 의해 수거 될 것이다.

## **10. equals()와 hashcode()에 대해 설명해 주세요.**

객체의 동등성을 비교하기 위한 메소드가 equals 이다. hashcode 가 같아야 equals 를 만족 시킨다. 자바 Object 의 equals 는 == 으로 구현되어 있다. hashcode 는 객체의 메모리 주소 기반으로 생성된다.

일반적으로 객체의 hashcode 와 함께 override 해주게 된다.

> 10-1. 본인이 hashcode() 를 정의해야 한다면, 어떤 점을 염두에 두고 구현할 것 같으세요?

객체를 유일하게 식별가능 해야한다.

> 10-2. 그렇다면 equals() 를 재정의 해야 할 때, 어떤 점을 염두에 두어야 하는지 설명해 주세요.

반사성, 대칭성, 추이성, 일관성ㅇ르 만족해야 한다.

## **11. IoC와 DI에 대해 설명해 주세요.**

Ioc : 프로그램의 제어를 개발자가 아닌 프레임워크가 담당. 객체의 생명주기를 프레임워크가 담당한다.

DI : IOC 를 구현하는 대표적인 방법. 장점으로는 테스트가 용이하다, 객체간의 결합도가 낮다.

필드 주입, 세터 주입, 생성자 주입이 존재한다.

필드 주입의 단점

1. 테스트가 힘들다. Spring 컨테이너 없이 의존성을 주입할 방법이 없다.
2. 불변성 보장 불가. final 키워드를 사용할 수 없으므로 null 체크를 개발자가 직접 해야한다.
3. 컴파일 시점에 순환 참조 감지할 수 없다.

세터 주입의 단점

1. 마찬가지로 불변성 보장 불가.
2. 컴파일 시점에 순환 참조 감지할 수 없다.
3. setter 메소드를 통해 주입되었으므로, 의존하는 객체가 변경될 수 있다.

> 11-1. 후보 없이 특정 기능을 하는 클래스가 딱 한 개하면, 구체 클래스를 그냥 사용해도 되지 않나요? 그럼에도 불구하고 왜 Spring에선 Bean을 사용 할까요?

객체간의 결합도를 낮추기 때문. 만약 그렇게 한다면 해당 객체를 호출하는 Bean 이 강하게 결합된다.

테스트가 용이해진다. 테스트시 Mock 객체를 활용해서 쉽게 대처할 수 없다.

> 11-2. Spring의 Bean 생성 주기에 대해 설명해 주세요.

1. 빈 인스턴스화
2. 의존성 주입
3. 생성 콜백메서드 실행
4. 빈 사용
5. 소멸 콜백

> 11-3. 프로토타입 빈은 무엇인가요?

요청마다 새로운 인스턴스가 생성되는 빈. 소멸 생성주기는 관리하지 않는다. 상태를 가진 서비스객체가 필요시 사용할 수 있다.

## **12. AOP에 대해 설명해 주세요.**

핵심 비즈니스 로직에서 부가적인 기능을 분리해 모듈화하는 프로그래밍 패러다임 입니다.

인터페이스를 구현한 경우에는 JDK dynamic proxy 가 사용됩니다. 구현하지 않은 경우에는 CGLIB 가 사용됩니다. 하지만, 강제로 cglib 를 사용하게 할 수 있다.

JDK dynamic proxy 는 자바 리플렉션을 이용하는 방법.

CGLIB 는 자바 오픈소스 라이브러리로, 바이트코드 조작을 통해 프록시를 구현한다.

> 12-1. @Aspect는 어떻게 동작하나요?

1. 컴포넌트 스캔과정에서 @Aspect 를 발견
2. 이 클래스들을 Advisor 로 전환. PointCut 과 Advice 정보 포함
3. 프록시 객체 생성. JDK dynamic proxy 혹은 CGLIB 로
4. 런타임 동작

## **13. Spring 에서 Interceptor와 Servlet Filter에 대해 설명해 주세요.**

두개 모두 웹요청의 전처리와 후처리를 담당한다.

Servlet Filter 의 경우에는, Spring Context 외부에서 동작한다.

Interceptor 의 경우에는 Dispatcher Servlet 과 Controller 사이에서 동작한다.

> 13-1. 설명만 들어보면 인터셉터만 쓰는게 나아보이는데, 아닌가요? 필터는 어떤 상황에 사용 해야 하나요?

인터셉터는 Dispatcher Servlet 을 통과한 요청에만 작동한다. 정적 리소스를 요청 같은것은 Filter 에서 처리해야한다. Spring Security 같은 경우에도 Servlet Filter chain 으로 구성되어 있다.

## **14. DispatcherServlet 의 역할에 대해 설명해 주세요.**

Front Controller 패턴을 구현한 서블릿이다. 핸들러 매핑을 하고, 핸들러 어댑터를 통해 컨트롤러의 메소드를 호출한다. 컨트롤러가 반환한 ModelAndView 객체를 받아 ViewResolver 를 통해 실제 View 를 찾고 렌더링한다.

> 14-1. 여러 요청이 들어온다고 가정할 때, DispatcherServlet은 한번에 여러 요청을 모두 받을 수 있나요?

요청이 들어오면 쓰레드 풀을 할당받는다. DispatcherServlet 은 thread-safe 하게 설계되어 있다. 따라서, 요청 thread 들은 dispatcher servlet 의 메소드 영역에 있는 코드만 읽고 가므로 동시성 문제가 전혀 발생되지 않는다.

> 14-2. 수많은 @Controller 를 DispatcherServlet은 어떻게 구분 할까요?

1. DispatcherServlet 이 등록될때, 여러 HandlerMapping 구현체들이 등록된다.
2. 그 중, RequestMappingHandlerMapping은 @RequestMapping, @GetMapping, @PostMapping 등의 어노테이션이 붙은 메소드들의 정보를 수집하여 내부적으로 매핑 레지스트리를 구성한다.
3. 요청이 들어오면 우선순위 대로 HanlderMapping 을 조회하여 요청을 처리할 메소드를 찾는다.

## **15. JPA와 같은 ORM을 사용하는 이유가 무엇인가요?**

1. 편의성을 위해 - 객체관계 모델 불일치성 해소
   1. 객체 매핑 편의성
   2. 쿼리 작성 편의성
   3. 더티 체킹
2. 데이터베이스 독립성

> 15-1. 영속성은 어떤 기능을 하나요? 이게 진짜 성능 향상에 큰 도움이 되나요?

엔티티 생명주기를 관리한다.

1. 1차 캐시 - 한번 조회한 엔티티를 메모리에 저장해두고, 다시 조회가 들어오면 db에 요청을 보내지 않고 저장해둔 엔티티를 보낸다.
2. 더티체킹
3. 쓰기지연
4. 지연 로딩

장점

1. 데이터베이스 조회 최소화
2. 쓰기 지연을 통한 네트워크 통신 감소
3. 지연 로딩을 통해 불필요한 데이터 로딩 방지

단점

1. 영속성 자체가 오버헤드 이다. 단순한 로직에서는 오히려 성능 저하가 일어난다. 메모리에 부담이 갈 수도있다.
2. 복잡한 쿼리의 경우 네이티브 sql 이나 다른 방법이 효율적이다.
3. 부적절한 지연 로딩인 경우 n+1 문제가 발생한다.

> 15-2. N + 1 문제에 대해 설명해 주세요.

하나의 쿼리로 해결할 수 있는데, 추가로 조인된 테이블에 N개의 쿼리가 나가는 현상을 말합니다.

fetch join 또는 entity graph 를 사용해서 해결 할 수있다.

## **16. @Transactional 은 어떤 기능을 하나요?**

선언적으로 메소드를 트랜잭션으로 감싸서 실행하게 한다.

isolation level, propagation 등의 속성이 있다. Propation Required 가 기본값이다. 현재 실행중인 트랜잭션을 사용한다. Requires_new 의 경우 항상 새로운 트랜잭션을 생성하고, 기존 트랜잭션은 중단시켜 놓는다. Spring AOP 기반으로 실행된다.

> 16-1. @Transactional(readonly=true) 는 어떤 기능인가요? 이게 도움이 되나요?

해당 트랜잭션이 읽기 전용임을 선언한다. 데이터베이스에 읽기 전용 쿼리 힌트를 제공한다. JPA 를 사용하는경우, 영속성 컨텍스트의 더티체킹을 비활성화 한다.

> 16-2. 그런데, 읽기에 트랜잭션을 걸 필요가 있나요? @Transactional을 안 붙이면 되는거 아닐까요?

필요 없는 경우도 있다. 하지만 동시성 문제로 필요한 경우도 존재한다. Isolation Level 등에 유의해야 한다. JPA 지연 로딩을 사용하는 경우에도 필요하다.

## **17. Java 에서 Annotation 은 어떤 기능을 하나요?**

코드에 메타데이터를 추가하는 역할을 한다. 컴파일러나 런타임 환경에 추가 정보를 제공한다.

> 17-1. 별 기능이 없는 것 같은데, 어떻게 Spring 에서는 Annotation 이 그렇게 많은 기능을 하는 걸까요?

Spring은 Java의 리플렉션 API를 사용하여 클래스, 메소드, 필드 등에 붙은 어노테이션을 확인하고, 그에 따른 처리를 수행한다. AOP, DI 등에 이용된다.

> 17-2. Lombok의 @Data를 잘 사용하지 않는 이유는 무엇일까요?

너무 과도하게 많은 기능을 담고 있다. 특히 setter 의 경우 캡슐화를 위반할 가능성이 있다.

## **18. Tomcat이 정확히 어떤 역할을 하는 도구인가요?**

자바 서블릿 기술을 지원하는 WAS 입니다. HTTP 요청을 받아 서블릿 인스턴스에 전달하고, 서블릿의 생명주기를 관리합니다.

> 18-1. 혹시 Netty에 대해 들어보셨나요? 왜 이런 것을 사용할까요?

Netty는 자바 기반의 비동기식, 이벤트 기반 네트워크 애플리케이션 프레임워크입니다. Netty는 고성능 네트워크 애플리케이션을 위해 설계되었다.
