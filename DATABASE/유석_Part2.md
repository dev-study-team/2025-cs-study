## 📚 9.  DB Join이 무엇인지 설명하고, 각각의 종류에 대해 설명해 주세요.
`JOIN`은 관계형 데이터베이스에서 두 개 이상의 테이블을 연결하여 원하는 데이터를 조회할 때 사용하는 SQL 연산입니다. 일반적으로 테이블 간의 `Primary Key`와 `Foreign Key` 관계를 활용하여 데이터를 결합합니다.

INNER JOIN은 두 테이블에서 `ON` 조건을 만족하는 **공통된 데이터만 조회**합니다.

LEFT JOIN은 왼쪽 테이블의 모든 데이터를 가져오고, 오른쪽 테이블에서 일치하는 데이터가 있으면 포함하며, 없으면 `NULL`로 표시됩니다.

RIGHT JOIN은 오른쪽 테이블의 모든 데이터를 가져오고, 왼쪽 테이블에서 일치하는 데이터가 있으면 포함하며, 없으면 `NULL`로 표시됩니다.

> 9-1. 사실, JOIN은 상당한 시간이 걸릴 수 있기에 내부적으로 다양한 구현 방식을 사용하고 있습니다. 그 예시에 대해 설명해 주세요.

총 3가지의 구현 방식이 있습니다. 먼저 Nested Loop Join은 두 테이블의 반복문을 순차적으로 비교하여 JOIN을 수행하는 방식입니다.

두번째로 Hash Join이 있습니다. 한쪽 테이블의 데이터를 메모리에 로드하여 해시 테이블을 만들고, 다른 테이블을 검색하면서 `JOIN`을 수행하는 방식입니다.

세번째로 Sort-Merge Join이 있습니다. 두 테이블을 `JOIN` 키 기준으로 정렬한 후, 하나씩 비교하면서 병합하는 방식입니다.

> 9-2. 그렇다면 입력한 쿼리에서 어떤 구현 방식을 사용하는지는 어떻게 알 수 있나요?

실행계획을 조회하면 됩니다. 실행 계획은 데이터베이스가 쿼리를 실행할 때 어떤 방식으로 수행하는지 예측된 실행 경로를 보여주는 기능입니다. 이를 통해 사용된 Join 알고리즘과 인덱스 활용 여부 등을 확인할 수 있습니다.

> 9-3. 앞 질문들을 통해 인덱스의 중요성을 알 수 있었는데, 그렇다면 JOIN의 성능도 인덱스의 유무의 영향을 받나요?

네. Join 성능은 인덱스의 유무에 큰 영향을 받습니다. 인덱스가 없으면 Join시 Full Table Scan을 해야 하므로 성능이 크게 저하될 수 있습니다. 반면에 적절한 인덱스를 사용하면 검색 범위가 줄어들고, 조인 성능이 크게 향상됩니다.

> 9-4. 3중 조인 부터는 동작 방식이 약간 바뀝니다. 어떻게 동작하는지, 그리고 그 방식이 성능에 어떠한 영향을 주는지 설명해 주세요.

a,b를 먼저 조인하고 조인된 결과와 c를 조인하는 방식으로 동작합니다. 주로 Nested Loop Join을 사용하며 보통 작은 테이블일 경우에 사용됩니다. 그리고 큰 테이블은 Hash Join으로 많이 사용합니다. 

## 📚 10.  B-Tree와 B+Tree에 대해 설명해 주세요.
B-Tree는 모든 노드에 데이터(키)와 포인터(자식 노드)가 저장되는 균형 탐색 트리입니다. 주로 랜덤 조회와 같은 일반적인 검색에 적합합니다.

B+Tree는 B-Tree를 확장한 구조로, 모든 데이터를 리프 노드에만 저장하는 방식입니다. 주로 범위 검색 및 순차 검색이 많은 경우에 적합합니다.

> 10-1. 그렇다면, B+Tree가 B-Tree에 비해 반드시 좋다고 할 수 있을까요? 그렇지 않다면 어떤 단점이 있을까요?

그렇지 않습니다. 랜덤 조회가 많은 경우에 B+Tree는 항상 리프노드까지 가야하므로 랜덤 조회 시 오히려 느려질 수 있습니다. 삽입/삭제 연산이 많으면 추가적인 인덱스 업데이트 비용이 발생할 수 있습니다. 리프 노드가 변경될 경우, 부모 노드의 인덱스 키도 갱신해야 합니다.

B+Tree는 인덱스 역할을 하는 내부 노드와 데이터를 저장하는 리프 노드로 구분됩니다. 그래서 리프 노드는 별도로 LinkedList 형태로 연결되어 있어 추가적인 공간이 필요합니다. 즉, B-Tree보다 더 많은 메모리를 사용할 수 있어 메모리 사용량이 중요한 환경에서는 B-Tree가 더 좋을 수 있습니다.

> 10-2. DB에서 RBT를 사용하지 않고, B-Tree/B+Tree를 사용하는 이유가 있을까요?

DB에서 Red-Black Tree 대신 B-Tree 혹은 B+Tree를 사용하는 이유는 주로 디스크 I/O 성능 최적화 때문입니다. RBT는 이진 균형 트리로 연산이 logN으로 빠른 편이지만, 트리의 높이가 상대적으로 크기 때문에 트리 높이가 상대적으로 얕아 디스크 I/O 측면에서 효율이 좋아 B트리를 사용합니다. 

또한 RBT는 단순한 메모리 내 검색 트리로 적합하지만, DBMS처럼 대량의 데이터를 다루는 환경에서는 트리 재구성 비용이 커져, 재구성 작업이 상대적으로 적고, 배치 처리에 최적화 된 B트리가 대량의 데이터를 다룰 때 성능이 더 좋습니다.

> 10-3. 오름차순으로 정렬된 인덱스가 있다고 할 때, 내림차순 정렬을 시도할 경우 성능이 어떻게 될까요? B-Tree/B+Tree의 구조를 기반으로 설명해 주세요.

B-Tree는 모든 노드에 데이터를 저장합니다. 내림차순 정렬을 수행할 경우 트리의 우측에서 좌측으로 탐색하면 가능한데, 한 번에 노드를 순차적으로 읽기 어렵고, 추가적인 탐색 비용이 발생할 수 있습니다.

B+Tree는 리프 노드에만 데이터를 저장하며, Linked List를 통해 순차 접근이 빠릅니다. 효율적인 역순 탐색이 가능하죠.

## 📚 11.  DB Locking에 대해 설명해 주세요.
DB락은 여러 커넥션에서 동시에 동일한 자원을 요청할 경우 순서대로 하나의 커넥션만 변경할 수 있게 해주는 기능입니다. 즉, 동시성을 제어하기 위한 기능입니다.

그리고 크게 공유락과 베타락으로 나눌 수 있습니다. 공유락은 데이터를 변경하지 않는 읽기 작업을 위해 잠그는 것을 말합니다. 또한 다른 세션에서 해당 데이터를 읽어도 정합성은 지켜지기 때문에 다른 세션의 공유락은 막지 않습니다. 하지만 베타락의 경우, 해당 데이터에 쓰기 작업을 수행하면 기존 세션의 작업 결과가 달라질 수 있기 때문에 베타락 획득은 막고 있습니다.

베타락은 데이터를 변경하는 작업을 위해 잠그는 것을 말합니다. 이 경우, 해당 데이터가 변경 중이기 때문에 데이터 정합성을 위해 다른 세션의 공유락, 베타락 획득을 막습니다.

> 11-1. Optimistic Lock/Pessimistic Lock에 대해 설명해 주세요.

낙관적 락은 DB 충돌 상황을 개선할 수 있는 방법으로, 현재 세션에서 값을 수정했다고 명시하면 다른 세션에서 동일한 조건으로 값을 수정할 수 없게 하는 것입니다. 이는 DB에서 제공해주는 것은 아니며 어플리케이션 레벨에서 잡아주는 락입니다. 비관적 락은 트랜잭션이 시작될 때 공유락 또는 베타락을 설정하고 시작하는 방법입니다. 

DB에서 데이터 충돌이 많이 발생할 수 있는 환경에서는 비관적 락을 사용하는 것이 좋습니다. 트랜잭션을 롤백해주면 빠르게 해결할 수 있기 때문입니다. 하지만 낙관적 락의 경우 수동 롤백 및 update를 한번씩 더 해줘야 하기 때문에 성능 면에서도 안좋습니다. 그래서 주로 데이터의 변경보다 조회가 많이 일어나는 환경에서 동시 접근 성능이 좋습니다.

> 11-2. 물리적인 Lock을 건다면, 만약 이를 수행중인 요청에 문제가 생겨 비정상 종료되면 Lock이 절대 해제되지 않는 문제가 생길 수도 있을 것 같습니다. DB는 이를 위한 해결책이 있나요? 없다면, 우리가 이 문제를 해결할 수 없을까요?

해결할 수 있습니다. 특정 요청에 문제가 생기면 대부분의 DBMS는 락을 일정 시간 후 자동으로 해제하는 타임아웃 기능을 제공합니다. 이 때 트랜잭션이 정상적으로 종료되지 않았다면 롤백한 뒤에 락을 해제합니다. DB단 이외에 어플리케이션 레벨에서 처리하는 방법도 존재합니다. Redis와 같은 분산락을 활용하여 DB에 직접적으로 락을 걸지 않아도 일정 시간 후에 락이 자동으로 해제되게 할 수 있습니다.

## 📚 12.  트래픽이 높아질 때, DB는 어떻게 관리를 할 수 있을까요?
가장 직관적인 방법으로는 스케일 업을 하는 것입니다. 하지만 비용이 비싸다는 한계 지점이 있어 수평 확장하는 방법으로 2가지가 생각나는 것 같습니다. 먼저 읽기와 쓰기 작업을 분리하여 Master-Slave 구조를 사용하여 각 역할에 따라 DB 노드를 분산시켜 트래픽을 수용할 수 있는 범위를 증가시킬 수 있습니다. 두 번째로는 샤딩입니다. 데이터를 유저ID, 지역 등과 같이 특정을 기준으로 여러 개의 DB로 분산시키는 것을 통해 대용량 트래픽에 대비할 수 있습니다.

> 12-1. DB 서버를 분산하지 않고, 트래픽을 감당할 수 있는 방법은 없을까요?

물론 있습니다. 크게 두 가지 방법이 있는데 첫 번째로, 트래픽이 많을수록 반복적인 조회가 많이 일어나는 환경일 것이라 예상됩니다. 이때 Redis, Memcached와 같은 인메모리 캐시를 활용하여 자주 사용되는 데이터를 캐싱하여 대용량 트래픽을 관리하는 것이 가능합니다. 

두 번째 방법으로는 자주 사용되는 검색 조건에 인덱스를 추가하여 쿼리 성능을 대폭 개선하는 것입니다. 예를 들어 email을 포함한 조회 쿼리가 많이 발생한다면 email 컬럼에 B-Tree 인덱스를 추가하여 성능을 향상시킬 수 있습니다.

## 📚 13. Schema가 무엇인가요?
스키마는 데이터베이스의 구조와 제약 조건에 대한 정의로 메타데이터라고도 합니다. 

> 13-1. Schema의 3계층에 대해 설명해 주세요.

네. 스키마에는 크게 외부, 개념, 내부 스키마로 나뉘어집니다. 먼저 외부 스키마는 사용자가 개인의 입장에서 필요로 하는 데이터베이스의 논리적 구조를 정의한 것입니다. 여기서 사용자는 SQL을 이용하여 DB를 쉽게 사용할 수 있습니다.

개념 스키마는 데이터베이스의 전체적인 논리적 구조로서, 데이터의 논리적 독립성을 보장합니다. 모든 응용 프로그램이나 사용자들이 필요로 하는 데이터를 종합한 조직 전체의 데이터베이스로 하나만 존재합니다. 

내부 스키마는 실제로 데이터베이스에 저장될 레코드의 물리적인 구조를 정의하고 데이터 파일의 구조, 인덱스, 저장 경로, 압축 방식 등을 결정하며, 물리적 독립성을 제공합니다.
