# 📀 데이터베이스 면접 질문 정리

## 📚 1. Key (기본키, 후보키, 슈퍼키 등등...) 에 대해 설명해 주세요.

기본 키는 후보 키에서 선택된 키로 NULL 값이 들어갈 수 없으며, 기본키로 선택된 속성은 동일한 값이 들어갈 수 없습니다.
후보키는 유일성과 최소성을 만족하는 키로 기본키가 될 수 있는 후보이기 때문에 후보 키라고 불립니다. 예시로 주민등록번호, 학번이 있습니다.
슈퍼키는 유일성을 만족하는 키로 예를 들면 학번과 이름을 합친 것, 주민등록번호와 학번을 합친 것입니다.

 > 1-1. 기본키는 수정이 가능한가요?

이론적으로는 가능하지만 수정하지 않는 것이 좋습니다. 
다른 테이블에서 해당 기본키를 참조하고 있다면, 기본 키를 수정하면 참조 무결성이 깨질 수 있습니다. 
또한 기본키는 일반적으로 클러스터링 인덱스를 가지기 때문에 수정하면 인덱스를 다시 정렬해야 해서  성능에 영향을 줄 수 있습니다.

> 1-2. 사실 MySQL의 경우, 기본키를 설정하지 않아도 테이블이 만들어집니다. 어떻게 이게 가능한 걸까요?

MySQL은 내부적으로 정렬 및 검색을 위해 암묵적인 기본키를 만들어 관리합니다. 하지만 이 경우에는 숨겨진 ROWID가 자동 생성되기 때문에 기본키를 설정하는 것보다 성능과 관리 측면에서 불리할 수 있습니다.

> 1-3. 외래키 값은 NULL이 들어올 수 있나요?

네. 외래키 값에 NULL이 들어올 수 있습니다. 참조 대상이 없어도 무결성 제약 조건을 위반하지 않지만 부모 테이블 삭제 시 외래키에 의해 함께 사라지는 ON DELETE CASCADE가 작동하지 않아 주의가 필요합니다.

> 1-4. 어떤 칼럼의 정의에 UNIQUE 키워드가 붙는다고 가정해 봅시다. 이 칼럼을 활용한 쿼리의 성능은 그렇지 않은 것과 비교해서 어떻게 다를까요?

조회 쿼리 성능은 좋아집니다. UNIQUE 컬럼에는 자동으로 고유 인덱스가 생성되어 인덱스 탐색이 가능합니다. 삽입 쿼리의 경우에는 UNIQUE 제약 조건이 있는 경우에 중복을 방지하기 위해 삽입 시 추가적인 검사 비용이 발생합니다.
또한 업데이트 쿼리에서는 UNIQUE 컬럼을 수정하는 경우에도 인덱스 갱신하는 비용이 발생합니다.

## 📚 2. RDB와 NoSQL의 차이에 대해 설명해 주세요.
 RDB는 테이블 간의 관계를 통해 데이터를 관리하기 때문에 데이터의 무결성을 보장할 수 있습니다. 반면에 NoSQL은 비관계형 데이터베이스로 다양한 데이터 모델을 사용하여 데이터를 관리하여 일관성을 보장합니다.
RDB는 명확한 데이터 구조를 보장하고 데이터 update가 잦은 시스템에 주로 사용됩니다. 반면에 NoSQL은 데이터 구조가 자유로워 데이터 중복이 발생할 수 있고 update가 자주 일어나지 않는 경우에 주로 사용합니다.
마지막으로 RDB는 수직적 확장을 통해 성능을 향상시키지만 NoSQL은 수평적 확장을 통해 성능을 향상시킵니다.

> 2-1. NoSQL의 강점과, 약점이 무엇인가요?

NoSQL은 대규모 데이터 처리를 효율적으로 수행할 수 있습니다. 이는 수평적 확장을 통해 성능을 향상시킬 수 있습니다. 또한 다양한 데이터 모델을 사용하여 데이터를 관리할 수 있습니다. 이는 유연한 데이터 구조를 제공하여 다양한 용도에 적합합니다.
그러나 NoSQL은 데이터의 무결성을 보장하지 않기 때문에, 데이터의 일관성을 유지하는 데 어려움이 있을 수 있습니다. 또한 각 데이터베이스마다 고유한 쿼리를 사용하기 때문에 러닝커브가 있을 수 있습니다.

> 2-2. RDB의 어떠한 특징 때문에 NoSQL에 비해 부하가 많이 걸릴 "수" 있을까요?

동시에 많은 트랜잭션이 발생하면 성능 저하가 발생할 수 있고 다중 사용자 환경에서 동시성이 높아질수록 처리비용이 증가합니다. 
그리고 RDB는 테이블 간의 관계를 맺고 있기 때문에 시스템이 커질 경우 Join문이 많은 복잡한 쿼리문 때문에 서버에 보다 많은 부하가 걸릴 수 있습니다.

> 2-3. NoSQL을 활용한 경험이 있나요? 있다면, 왜 RDB를 선택하지 않고 해당 DB를 선택했는지 설명해 주세요.

실제로 NoSQL을 활용한 경험은 없지만 대량의 데이터를 빠르게 처리해야 하거나, 유연한 스키마가 필요할 때, 그리고 수평적 확장이 필요한 요구사항일 때 주로 사용하는 것으로 알고 있습니다.

## 📚 3. 트랜잭션이 무엇이고, ACID 원칙에 대해 설명해 주세요.

트랜잭션이란 여러 개의 연산을 묶은 하나의 논리적인 작업 단위를 말합니다.

원자성(Atomicity)은 트랜잭션이 데이터베이스에 모두 반영되거나 모두 반영되지 않아야 한다는 원칙입니다. 이를 통해 트랜잭션에서 발생할 수 있는 오류로부터 데이터를 보호할 수 있습니다.

일관성(Consistency)은 트랜잭션이 실행되기 전과 후에 데이터베이스가 일관된 상태를 유지해야 한다는 원칙입니다. 이는 데이터베이스 무결성 제약 조건이 항상 만족되어야 함을 의미합니다.

독립성(Isolation)은 동시에 실행되는 트랜잭션이 서로 영향을 주지 않아야 한다는 원칙입니다. 이를 통해 여러 트랜잭션이 동시에 실행되더라도 데이터의 일관성을 보장할 수 있습니다.

지속성(Durability)은 성공적으로 완료된 트랜잭션의 결과가 영구적으로 반영되어야 한다는 원칙입니다. 이는 시스템 장애가 발생하더라도 데이터가 손실되지 않도록 보장합니다.


> 3-1. ACID 원칙 중, Durability를 DBMS는 어떻게 보장하나요?

DBMS의 로그를 활용하여 보장할 수 있습니다. 마지막 체크포인트 시점부터 최근 로그까지 모든 로그를 탐색하면서, 어디서부터 어떤 트랜잭션을 복구해야 하는지를 분석합니다.
복구를 시작해야 하는 시점부터 장애가 발생한 시점의 직전까지 모든 로그를 REDO합니다. 트랜잭션을 모두 재 반영하는 것입니다.
로그를 시간 내림차순으로 탐색하면서 필요에 따라 로그를 UNDO합니다. 즉, 트랜잭션 롤백을 하는 것입니다.

> 3-2. 트랜잭션을 사용해 본 경험이 있나요? 어떤 경우에 사용할 수 있나요?

상품을 등록하는 과정에서 사용해본 경험이 있습니다. 상품을 등록할 때 product, productImage, productComponent, productOption을 하나의 비즈니스 로직에서 동시에 저장하는 경우에 사용하였습니다. 즉, 여러 개의 데이터 변경이 하나의 작업에서 이뤄질 때 데이터 정합성을 유지하기 위해 사용하였습니다.

> 3-3. 읽기에는 트랜잭션을 걸지 않아도 될까요?

일반적인 SELECT 조회에는 트랜잭션을 걸지 않아도 되지만, Repeatable Read 혹은 Dirty Read가 발생하는 작업에서는 트랜잭션을 걸어줘야 합니다. 트랜잭션을 걸지 않으면 여러 번 조회하는 도중에 데이터가 변경될 수 있어 데이터 정합성이 깨지는 현상이 발생합니다.

## 📚 트랜잭션 격리 레벨에 대해 설명해 주세요.

트랜잭션 격리 수준이란 여러 트랜잭션이 동시에 처리될 때 특정 트랜잭션이 다른 트랜잭션에서 변경하거나 조회하는 데이터를 볼 수 있게 허용할 지 말지를 결정하는 것입니다.

**Serializable**은 가장 엄격한 관리 수준으로, 이름 그대로 트랜잭션을 순차적으로 진행시킵니다. 여러 트랜잭션이 동일한 레코드에 접근할 수 없으므로, 어떠한 데이터 부정합 문제도 발생하지 않습니다. 하지만 트랜잭션이 순차적으로 처리되어야 하여 동시 처리 성능이 매우 떨어집니다.

그 아랫 단계인 **Repeatable Read**는 변경 전의 레코드를 언두 공간에 백업하여 변경 전/후 데이터가 모두 존재하므로 동일한 레코드에 대해 여러 버전이 있다하여 MVCC(Multi Version Concurrency Control)라고 부릅니다. 한 트랜잭션 내에서 동일한 결과를 보장하지만, 새로운 레코드가 추가되는 경우에 부정합이 생길 수 있습니다. 현재 트랜잭션보다 늦게 실행된 트랜잭션이 추가한 레코드는 무시하는 격리 수준입니다.

(락이 있는 읽기에 대해서는 팬텀리드가 발생할 수 있습니다. 하지만 MySQL은 갭락으로 넥스트 키 락을 걸기 때문에 팬텀리드가 발생하지 않습니다.

다음 단계인 **Read Committed**는 커밋된 데이터만 조회할 수 있습니다. 해당 수준은 팬텀리드에 더해 Non-Repeatable Read 문제까지 발생할 수 있습니다. 한 트랜잭션 내에서 두개의 읽기 사이에 추가된 데이터에 의해 다르게 조회될 수 있습니다.

마지막 단계인 **Read Uncommitted**는 커밋하지 않은 데이터도 접근할 수 있는 격리수준입니다. 다른 트랜잭션의 작업이 커밋 또는 롤백되지 않아도 즉시 보이게 되어 더티 리드와 같은 부정합 문제까지 발생할 수 있으며 팬텀리드, Repeatable Read 또한 발생한다.

> 4-1. 모든 DBMS가 4개의 레벨을 모두 구현하고 있나요? 그렇지 않다면 그 이유는 무엇일까요?

DBMS마다 성능과 일관성에 따라 다르게 고려하기 때문에 모두 구현하고 있지 않습니다. 또한 NoSQL에서는 ACID 트랜잭션을 완벽하게 지원하고 있지 않기 때문에 모두 구현하지 않는 예시로 볼 수 있습니다.
그리고 PostgreSQL의 경우에도 Read Uncommitted를 지원하지 않습니다.

> 4-2. 만약 MySQL을 사용하고 있다면, (InnoDB 기준) Undo 영역과 Redo 영역에 대해 설명해 주세요.

언두 영역은 InnoDB 스토리지 엔진이 트랜잭션과 격리 수준을 보장하기 위해 DML로 변경되기 이전 버전의 데이터를 별도로 백업하는 공간을 의미합니다. 그리고 리두로그는 DDL 또는 DML 문장에 의해 데이터베이스에 저장된 값 또는 구조에 변경사항이 생기는 경우에 이러한 정보를 놓치지 않고 저장하는 메모리영역입니다.

> 4-3. 그런데, 스토리지 엔진이 정확히 무엇을 하는 건가요?
> 
스토리지 엔진은 요청된 SQL 문장을 분석하거나 최적화를 하며 디스크 스토리지의 저장 및 읽기를 담당합니다.
