## **1. Key (기본키, 후보키, 슈퍼키 등등...) 에 대해 설명해 주세요.**

후보키 : 행을 구분할 수 있는 최소한의 column 들만의 집합

슈퍼키 : 행을 구분할 수 있는 column 들의 집합

기본키 : 후보키중 하나를 선택. NULL 값을 지닐 수 없다.

> 1-1. 기본키는 수정이 가능한가요?

MySQL 에선 가능합니다. 다만 권장하지 않습니다.

> 1-2. 사실 MySQL의 경우, 기본키를 설정하지 않아도 테이블이 만들어집니다. 어떻게 이게 가능한 걸까요?

RDBMS 개념적으로는 반드시 존재해야 하지만, 좀더 유연성을 위해 MySQL 에선 기본키 없이 테이블 생성이 가능하다.

> 1-3. 외래키 값은 NULL이 들어올 수 있나요?

가능합니다.

> 1-4. 어떤 칼럼의 정의에 UNIQUE 키워드가 붙는다고 가정해 봅시다. 이 칼럼을 활용한 쿼리의 성능은 그렇지 않은 것과 비교해서 어떻게 다를까요?

MySQL 에선 UNIQUE 키워드가 붙을 경우 자동으로 인덱스를 생성해준다. 따라서, 인덱스를 활용하는 쿼리의 경우 성능이 향상될 수 있다.

## **2. RDB와 NoSQL의 차이에 대해 설명해 주세요.**

일반적으로, RDB 의 장점은 다음과 같습니다.

1. 데이터 무결성
2. ACID 트랜잭션 지원
3. 검증된 안정성

NoSQL 의 장점은 다음과 같습니다.

1. 유연한 스키마 설정
2. 수평적 확장성

> 2-1. RDB의 어떠한 특징 때문에 NoSQL에 비해 부하가 많이 걸릴 "수" 있을까요? (주의: 무조건 NoSQL이 RDB 보다 빠르다라고 생각하면 큰일 납니다!)

다중 조인으로 인한 성능 저하, 트랜잭션 처리로 인한 오버헤드, NoSQL 에 비해 분산환경에 덜 적합한 특성때문에.

> 2-2. NoSQL을 활용한 경험이 있나요? 있다면, 왜 RDB를 선택하지 않고 해당 DB를 선택했는지 설명해 주세요.

Redis 를 캐싱용으로 사용해본 경험이 있다. 성능때문에 In-memory 기반 DB 인 레디스를 사용했다.

## **3. 트랜잭션이 무엇이고, ACID 원칙에 대해 설명해 주세요.**

트랜잭션 : 일련의 데이터 조작과정을 하나의 작업 단위로 보는것

Atomic : 원자성. 트랜잭션이 일어난다면 행위가 모두 일어나야 하고, 그렇지 않나면 모두 안일어나야 한다.

Consistency : 트랜잭션 실행 전후로 데이터베이스가 동일한 상태를 유지해야 한다.

Isolation : 트랜잭션 간에 격리가 일어나 상호간의 간섭을 일으키면 안된다.

Durability : 트랜잭션의 결과는 영구적으로 보존되어야 한다.

> 3-1. ACID 원칙 중, Durability를 DBMS는 어떻게 보장하나요?
1. InnoDB 는 데이터 변경 사항을 메모리 버퍼에 적용하기 전에 Redo Log 에 기록해 둔다.
2. InnoDB 백그라운드 스레드는 주기적으로 리두로그에 쌓인 변경내역(더티 페이지)를 디스크 파일에 적용시켜 준다. 더티 페이지 중 일부만 기록되는 현상을 방지하기 위해 더티 페이지들을 묶어서 DoubleWrite Buffer 에 기록해 준다.

> 3-2. 읽기에는 트랜잭션을 걸지 않아도 될까요?
데이터 정합성을 위해 트랜잭션을 걸 필요가 있는 경우도 존재한다.

## **4. 트랜잭션 격리 레벨에 대해 설명해 주세요.**

MySQL 의 InnoDB 는 기본적으로 Undo Log 를 통해 MVCC 를 구현했다. 커밋되지 않은 데이터는 Undo Log 에 쌓이게 된다. 타 트랜잭션에서 해당 데이터를 볼때는 직접 해당 페이지를 보는것이 아니라 Undo Log에 쌓여있는 값을 확인한다.

1. Read Uncommited
    
    트랜잭션 간의 격리성이 최소로 줄어든 상황이다. 타 트랜잭션의 커밋되지 않은 데이터를 볼 수 있다.
    
2. Read Commited
    
    타 트랜잭션의 Commit 이 끝난 데이터만 확인가능하다.
    
3. Repeatable Read
    
    현재 트랜잭션에서 확인한 데이터가 도중 타 트랜잭션에서 커밋되어서 변경되어도 현재 트랜잭션으로부터는 관리되는 환경이다. InnoDB 에서 디폴트 격리 레벨로 사용된다. 첫번째 read 의 snapshot 을 찍어서 해당 트랜잭션 내에서는 그 snapshot 안에 있는 데이터로만 처리하므로 phantom read 가 발생하지 않는다.
    
4. Serializable
    
    가장 엄격한 격리 레벨. InnoDB 에서 모든 read 가 S-lock 을 걸고 실행이 된다.
    

> 4-1. 모든 DBMS가 4개의 레벨을 모두 구현하고 있나요? 그렇지 않다면 그 이유는 무엇일까요?


그렇지 않다. 격리성이 필요하지 않을수도 있기 때문이다.

> 4-2. 만약 MySQL을 사용하고 있다면, (InnoDB 기준) Undo 영역과 Redo 영역에 대해 설명해 주세요.


Undo Log - 트랜잭션간 격리를 위해 사용된다.

Redo Log - write buffer 역할. durability 를 위해 디스크에 데이터가 쓰이기 전 보관해주는 역할도 한다.

> 4-3. 그런데, 스토리지 엔진이 정확히 무엇을 하는 건가요?


디스크에 데이터를 쓰고 읽는 행위와 그 연관된 모든 행위(Transaction 관리, 락 관리, 인덱싱)를 한다.

## **5. 인덱스가 무엇이고, 언제 사용하는지 설명해 주세요.**

Read 성능을 향상 시키기위해 도입한 방편이다. InnoDB 에서는 pk가 클러스터 형식으로 B+ 트리로 구성된다.

> 5-1. 일반적으로 인덱스는 수정이 잦은 테이블에선 사용하지 않기를 권합니다. 왜 그럴까요?

Read 성능을 향상 시키기위한 트레이드 오프로 수정, 삭제, 삽입시 추가적인 operation 이 필요하다.

> 5-2. ORDER BY/GROUP BY 연산의 동작 과정을 인덱스의 존재여부와 연관지어서 설명해 주세요.
> 

ORDER BY 경우, 정렬 기준 컬럼에 인덱스가 있으면 이미 정렬된 인덱스를 순차적으로 스캔

GROUP BY 경우, GROUP BY 컬럼에 인덱스가 있으면 인덱스 스캔으로 그룹화.

> 5-3. 기본키는 인덱스라고 할 수 있을까요? 그렇지 않다면, 인덱스와 기본키는 어떤 차이가 있나요?
> 

기본키는 각 레코드를 판별하기 위한 도구이고 인덱스는 검색성능을 향상시키기 위한 자료구조 이다.

InnoDB 에서는 기본키가 기본적으로 인덱스로 적용된다. 

> 5-4. 외래키와 인덱스 관계는 어떤가요?
> 

외래키는 단순히 참조 무결성을 보장하는 제약조건입니다. 일반적으로 외래키에 인덱스를 걸어주는 것을 권장합니다. InnoDB 에서는 자동으로 외래키에 인덱스를 생성해준다.

> 5-5. 인덱스가 데이터의 물리적 저장에도 영향을 미치나요? 그렇지 않다면, 데이터는 어떤 순서로 물리적으로 저장되나요?
> 

InnoDB 에서는 영향을 미친다. 기본적으로 pk 기반 클러스터 인덱스를 생성한다. 즉, 디스크에 저장되는 순서가 pk 순으로 저장된다는 뜻이다.

> 5-6. 우리가 아는 RDB가 아닌 NoSQL (ex. Redis, MongoDB 등)는 인덱스를 갖고 있나요? 만약 있다면, RDB의 인덱스와는 어떤 차이가 있을까요?
> 

Redis 는 기본적으로 key-value 형태 자료구조 이므로 인덱스가 필요없다.

MongoDB 의 경우 B-tree 기반 인덱스를 제공한다. TTL, 부분 인덱스 같은 기능을 추가적으로 제공한다.

> 5-7. (A, B) 와 같은 방식으로 인덱스를 설정한 테이블에서, A 조건 없이 B 조건만 사용하여 쿼리를 요청했습니다. 해당 쿼리는 인덱스를 탈까요?
> 

해당 쿼리는 인덱스를 타지 않고 풀스캔 서치를 진행한다.

## **6. RDBMS, NoSQL에서의 클러스터링/레플리케이션 방식에 대해 설명해 주세요.**

Replication

기본적으로 단일 마스터 - 다중 레플리카의 형태를 띈다. 

InnoDB 의 경우 바이너리 로그 파일을 이용하여 비동기 혹은 반동기 방식으로 마스터에 커밋된 데이터를 레플리카들이 가져가게 된다.

Clustering

다중 프라이머리 혹은 단일 프라이머리 방식을 지원한다. 한 노드에서 발생된 변경이 다른 노드에 전파된다. Redis clustering 의 경우 노드들 끼리 gossip protocol 을 통해 소통하며 샤딩과 failover 를 함께 포함하는 개념이다.

> 6-1. 분산 환경에서 트랜잭션을 어떻게 관리할 수 있을까요?
> 
1. 2PC
    
    먼저, 코디네이터가 모든 트랜잭션 참여자에게 트랜잭션이 진행될거라는 신호를 보내고 참여자들은 참여 가능여부를 응답으로 보낸다. 이때, 하나의 참여자라도 참여가 불가능 할경우 트랜잭션을 진행하지 않고 롤백을 한다.
    
2. SAGA 패턴
    
    마이크로서비스 간에 통신을 주고받으며 트랜잭션을 처리.
    
    Choreography 방식은 메세지 브로커를 통해 트랜잭션 보상/실패 이벤트를 주고 받으며 전체 트랜잭션을 진행한다. Orchestration 방식은 매니저가 트랜잭션 진행 상태를 관리한다.
    

> 6-2. 마스터, 슬레이브 데이터 동기화 전 까지의 데이터 정합성을 지키는 방법은 무엇이 있을까요?
> 

절대적인 정합성이 필요하다면, 커밋시에 동기적으로 데이터 정합성을 지켜주면 된다.

> 6-3. 다중 트랜잭션 상황에서의 Deadlock 상황과, 이를 해결하기 위한 방법에 대해 설명해 주세요.
> 

InnoDB 에서는 내부적으로 데드락 감지 알고리즘을 통해 트랜잭션 대기 상태를 검사한다. 만약 순환 대기가 발생하면 롤백에 비용이 적게 드는 트랜잭션을 골라 롤백 시킨다.

> 6-4. 샤딩 방식은 무엇인가요? 만약 본인이 DB를 분산해서 관리해야 한다면, 레플리케이션 방식과 샤딩 방식 중 어떤 것을 사용할 것 같나요?
> 

두 기술은 상황에 따라 따로 써야할수도 있고 동시에 적용해야 할 수도 있습니다. 만약 읽기 성능이 극단적으로 많이 필요한 경우에는 레플리케이션을 우선적으로 고려해 볼 수 있습니다. 그리고, 테이블이 매우 비대해지거나 쓰기 성능이 더 필요한 경우에는 샤딩을 우선 고려해 볼 것 같습니다.

## **7. 정규화가 무엇인가요?**

데이터 무결성을 위해 테이블을 분리하는 것.

제 1정규형 : 하나의 칼럼에는 하나의 값만 들어야 한다.

제 2정규형: 완전 함수 종속을 만족. 기본키의 일부로는 속성이 결정되면 안된다.

제 3정규형: 속성들간 이행 종속성이 없어야 한다. A로 B가 결정되고 B로 C가 결정되면 테이블 분리를 해야한다.

BCNF: 모든 결정자가 후보키여야 한다.  

> 7-1. 정규화를 하지 않을 경우, 발생할 수 있는 이상현상에 대해 설명해 주세요.
> 

삽입 이상 - 필요하지 않은 정보도 삽입해야 하는 경우가 생김

수정 이상 - 중복된 데이터를 수정할때, 일부 데이터만 수정해서 데이터 불일치가 발생

삭제 이상 - 데이터 삭제시 의도하지 않은 정보들도 삭제하게 됨.

> 7-2. 정규화가 무조건 좋은가요? 그렇지 않다면, 어떤 상황에서 역정규화를 하는게 좋은지 설명해 주세요.
> 

읽기 성능을 더 향상시키고 싶은 경우 역정규화를 시킬 수도 있다.

## **8. View가 무엇이고, 언제 사용할 수 있나요?**

view 는 일종의 가상 테이블 역할을 한다. 본질적으로 sql 쿼리문이라고 볼 수 있다. 사용자별 보안 등급이 필요하거나 추상적인 데이터를 제공할 필요가 있을때 주로 사용한다.

> 8-1. 그렇다면, View의 값을 수정해도 실제 테이블에는 반영되지 않나요?
> 

InnoDB 의 경우, 단일 테이블 기반 뷰의 경우에 수정사항이 반영된다.

## **9. DB Join이 무엇인지 설명하고, 각각의 종류에 대해 설명해 주세요.**

Join : 두개 이상의 테이블을 하나의 집합으로 만드는 연산.

1. Inner Join
    
    기준 테이블과 join 테이블의 공통적인 컬럼을 가지고 결합하는 조인
    
2. Left Outer Join
    
    기준 테이블의 모든 행과 조인 조건에 부합하는 join 테이블 데이터를 확인할때 사용한다.
    
3. Full Outer Join
    
    기준 테이블과 join 테이블의 합집합
    
4. Cross Join
    
    두 테이블의 카테시안 곱을 확인할때 사용.
    

> 9-1. 사실, JOIN은 상당한 시간이 걸릴 수 있기에 내부적으로 다양한 구현 방식을 사용하고 있습니다. 그 예시에 대해 설명해 주세요.
> 

Driving Table 과 Driven Table 선택이 중요하다. Driving Table 을 반복하면서 조건에 맞는 Driven Table을 찾는 형식이다. 큰틀에서 Driving Table 의 row 수는 적게, Driven Table은 index 를 적용하도록 하면 된다.

일반적으로는 Nested Loop Join 을 사용한다.

두 칼럼 모두 인덱스가 없는 경우 : MySQL 8.0.18 이전까지는 블록 네스티드 루프 조인 사용. 이후로는 해시 조인 사용.

> 9-2. 그렇다면 입력한 쿼리에서 어떤 구현 방식을 사용하는지는 어떻게 알 수 있나요?
> 

MySQL 경우, EXPLAIN 키워드를 사용하면 동작 방식을 예측할 수 있다.

- **type 컬럼**: 'eq_ref', 'ref'는 인덱스를 통한 효율적인 조인, 'ALL'은 테이블 풀 스캔
- **rows 컬럼**: 처리할 것으로 예상되는 행 수
- **Extra 컬럼**: 'Using index'는 인덱스만으로 쿼리를 처리, 'Using join buffer'는 블록 중첩 루프 조인

> 9-3. 앞 질문들을 통해 인덱스의 중요성을 알 수 있었는데, 그렇다면 JOIN의 성능도 인덱스의 유무의 영향을 받나요?
> 

두 칼럼 모두 인덱스가 있는 경우 : 옵티마이저가 적절히 Driving Table 을 선택한다.

한 칼럼만 인덱스가 있는 경우 : 인덱스가 있는 테이블이 Driven Table 이 된다.

> 9-4. 3중 조인 부터는 동작 방식이 약간 바뀝니다. 어떻게 동작하는지, 그리고 그 방식이 성능에 어떠한 영향을 주는지 설명해 주세요.
> 

N중 조인때에도 기본 방식은 동일하다. A,B,C 세개의 테이블을 조인해야 할때, A와 B 테이블을 조인한 AB 임시 결과셋을 만들고 AB와 C를 조인한다. 다만 조인수가 늘어날 수록 조인 순서 중요성이 올라갑니다. 또한, 조인 버퍼와 임시 테이블 사용 여부 확인 등이 필요하다.

## **10. B-Tree와 B+Tree에 대해 설명해 주세요.**

Balanced Tree 의 일종으로, 하나의 노드에 여러개의 데이터가 들어갈 수 있다. 검색, 삽입, 삭제 작업이 O(logN) 이다.

B-Tree 의 경우 모든 노드에 데이터가 들어간다. B+ Tree의 경우 Leaf Node에만 데이터가 들어간다.

B+ Tree 의 경우 Leaf Node 들끼리 Linked List 로 연결되어 있다.

B+ 트리의 경우 내부 노드에 키값만 저장하므로 더 많은 키를 저장할 수 있다. 이는 메모리에 더많은 키를 보관할 수 있다는 뜻이므로 캐시 힛 비율이 늘어나게 된다.

> 10-1. 그렇다면, B+Tree가 B-Tree에 비해 반드시 좋다고 할 수 있을까요? 그렇지 않다면 어떤 단점이 있을까요?
> 

Range Query 사용시 B+ Tree가 훨씬 유리하다. 다만, 일반 노드에 데이터를 담을 수 있는 B-Tree 의 특징을 고려했을때, 단일 쿼리만을 사용하는 경우 B-Tree 가 더 유용할 수도 있다. 

> 10-2. DB에서 RBT를 사용하지 않고, B-Tree/B+Tree를 사용하는 이유가 있을까요?
> 

Binary Tree의 경우 Height 가 매우 커질 수 있는데, 이는 disk IO operation 횟수를 늘려주기 때문에 불리하다.

또한, Disk IO 는 Block 단위로 이뤄지므로 여러개의 데이터를 하나의 노드에 담는 B-Tree 계열이 유리하다.

> 10-3. 오름차순으로 정렬된 인덱스가 있다고 할 때, 내림차순 정렬을 시도할 경우 성능이 어떻게 될까요? B-Tree/B+Tree의 구조를 기반으로 설명해 주세요.
> 

B+ Tree : 인덱스 레인지 스캔을 역방향으로 실시한다.

B Tree : 기본적으로 레인지 스캔에 불리하다. 중위 순회를 거꾸로 실행해야 하면 된다.

## **11. DB Locking에 대해 설명해 주세요.**

S-lock 과 X-lock

InnoDB 에는 추가적으로 IS 와 IX 락이 존재한다. 테이블에 잠금 의도를 표시해서 다른 트랜잭션들에게 알리기 위한 목적이다.

Record Lock : 클러스터링 인덱스에 걸리게 된다.

Gap Lock : 레코드와 레코드 사이의 간격에 Insert 되는 것을 제어한다.

Next Key lock : 레코드락 + 갭락. Repeatable Read 격리 수준일때, 사용된다.

> 11-1. Optimistic Lock/Pessimistic Lock에 대해 설명해 주세요.
> 
1. Optimistic Lock
    
    기본적으로 데이터 충돌이 드물게 일어난다는 낙관적인 가정에 기반한 동시성 제어 방식. 데이터를 수정할때 실제로 락을 걸지는 않는다. 대신 타임스탬프나 버전 컬럼을 추가하여, 업데이트시 현재 값과 읽었을 당시 값을 비교한다. 충돌시 어플리케이션에서 재시도 로직을 구현해야 한다.
    
2. Pessimistic Lock
    
    데이터 충돌이 자주 일어날거라는 비관적인 가정에 기반한 동시성 제어 방식. 실제로 데이터베이스에서 제공하는 락을 걸고 데이터를 수정한다. 락으로 인한 오버헤드로 성능이 저하된다. 데드락 발생 가능성이 생긴다.
    

> 11-2. 물리적인 Lock을 건다면, 만약 이를 수행중인 요청에 문제가 생겨 비정상 종료되면 Lock이 절대 해제되지 않는 문제가 생길 수도 있을 것 같습니다. DB는 이를 위한 해결책이 있나요? 없다면, 우리가 이 문제를 해결할 수 없을까요?
> 

대부분의 dbms 는 락에 타임아웃을 설정할 수 있다. 또한, InnoDB 는 데드락 탐지 알고리즘을 사용해서 하나의 트랜잭션을 킬하는 방식을 사용한다.

## **12. 트래픽이 높아질 때, DB는 어떻게 관리를 할 수 있을까요?**

Replication, Clustering 도입. 샤딩. CQRS 패턴 도입.

> 12-1. DB 서버를 분산하지 않고, 트래픽을 감당할 수 있는 방법은 없을까요?
> 

수직적 확장. 테이블 파티셔닝. 캐싱 매커니즘 도입. 적절한 인덱스 사용. 비동기 처리 도입.