## **1. Key (기본키, 후보키, 슈퍼키 등등...) 에 대해 설명해 주세요.**

후보키 : 행을 구분할 수 있는 최소한의 column 들만의 집합

슈퍼키 : 행을 구분할 수 있는 column 들의 집합

기본키 : 후보키중 하나를 선택. NULL 값을 지닐 수 없다.

> 1-1. 기본키는 수정이 가능한가요?

MySQL 에선 가능합니다. 다만 권장하지 않습니다.

> 1-2. 사실 MySQL의 경우, 기본키를 설정하지 않아도 테이블이 만들어집니다. 어떻게 이게 가능한 걸까요?

RDBMS 개념적으로는 반드시 존재해야 하지만, 좀더 유연성을 위해 MySQL 에선 기본키 없이 테이블 생성이 가능하다.

> 1-3. 외래키 값은 NULL이 들어올 수 있나요?

가능합니다.

> 1-4. 어떤 칼럼의 정의에 UNIQUE 키워드가 붙는다고 가정해 봅시다. 이 칼럼을 활용한 쿼리의 성능은 그렇지 않은 것과 비교해서 어떻게 다를까요?

MySQL 에선 UNIQUE 키워드가 붙을 경우 자동으로 인덱스를 생성해준다. 따라서, 인덱스를 활용하는 쿼리의 경우 성능이 향상될 수 있다.

## **2. RDB와 NoSQL의 차이에 대해 설명해 주세요.**

일반적으로, RDB 의 장점은 다음과 같습니다.

1. 데이터 무결성
2. ACID 트랜잭션 지원
3. 검증된 안정성

NoSQL 의 장점은 다음과 같습니다.

1. 유연한 스키마 설정
2. 수평적 확장성

> 2-1. RDB의 어떠한 특징 때문에 NoSQL에 비해 부하가 많이 걸릴 "수" 있을까요? (주의: 무조건 NoSQL이 RDB 보다 빠르다라고 생각하면 큰일 납니다!)

다중 조인으로 인한 성능 저하, 트랜잭션 처리로 인한 오버헤드, NoSQL 에 비해 분산환경에 덜 적합한 특성때문에.

> 2-2. NoSQL을 활용한 경험이 있나요? 있다면, 왜 RDB를 선택하지 않고 해당 DB를 선택했는지 설명해 주세요.

Redis 를 캐싱용으로 사용해본 경험이 있다. 성능때문에 In-memory 기반 DB 인 레디스를 사용했다.

## **3. 트랜잭션이 무엇이고, ACID 원칙에 대해 설명해 주세요.**

트랜잭션 : 일련의 데이터 조작과정을 하나의 작업 단위로 보는것

Atomic : 원자성. 트랜잭션이 일어난다면 행위가 모두 일어나야 하고, 그렇지 않나면 모두 안일어나야 한다.

Consistency : 트랜잭션 실행 전후로 데이터베이스가 동일한 상태를 유지해야 한다.

Isolation : 트랜잭션 간에 격리가 일어나 상호간의 간섭을 일으키면 안된다.

Durability : 트랜잭션의 결과는 영구적으로 보존되어야 한다.

> 3-1. ACID 원칙 중, Durability를 DBMS는 어떻게 보장하나요?
1. InnoDB 는 데이터 변경 사항을 메모리 버퍼에 적용하기 전에 Redo Log 에 기록해 둔다.
2. InnoDB 백그라운드 스레드는 주기적으로 리두로그에 쌓인 변경내역(더티 페이지)를 디스크 파일에 적용시켜 준다. 더티 페이지 중 일부만 기록되는 현상을 방지하기 위해 더티 페이지들을 묶어서 DoubleWrite Buffer 에 기록해 준다.

> 3-2. 읽기에는 트랜잭션을 걸지 않아도 될까요?
데이터 정합성을 위해 트랜잭션을 걸 필요가 있는 경우도 존재한다.

## **4. 트랜잭션 격리 레벨에 대해 설명해 주세요.**

MySQL 의 InnoDB 는 기본적으로 Undo Log 를 통해 MVCC 를 구현했다. 커밋되지 않은 데이터는 Undo Log 에 쌓이게 된다. 타 트랜잭션에서 해당 데이터를 볼때는 직접 해당 페이지를 보는것이 아니라 Undo Log에 쌓여있는 값을 확인한다.

1. Read Uncommited
    
    트랜잭션 간의 격리성이 최소로 줄어든 상황이다. 타 트랜잭션의 커밋되지 않은 데이터를 볼 수 있다.
    
2. Read Commited
    
    타 트랜잭션의 Commit 이 끝난 데이터만 확인가능하다.
    
3. Repeatable Read
    
    현재 트랜잭션에서 확인한 데이터가 도중 타 트랜잭션에서 커밋되어서 변경되어도 현재 트랜잭션으로부터는 관리되는 환경이다. InnoDB 에서 디폴트 격리 레벨로 사용된다. 첫번째 read 의 snapshot 을 찍어서 해당 트랜잭션 내에서는 그 snapshot 안에 있는 데이터로만 처리하므로 phantom read 가 발생하지 않는다.
    
4. Serializable
    
    가장 엄격한 격리 레벨. InnoDB 에서 모든 read 가 S-lock 을 걸고 실행이 된다.
    

> 4-1. 모든 DBMS가 4개의 레벨을 모두 구현하고 있나요? 그렇지 않다면 그 이유는 무엇일까요?


그렇지 않다. 격리성이 필요하지 않을수도 있기 때문이다.

> 4-2. 만약 MySQL을 사용하고 있다면, (InnoDB 기준) Undo 영역과 Redo 영역에 대해 설명해 주세요.


Undo Log - 트랜잭션간 격리를 위해 사용된다.

Redo Log - write buffer 역할. durability 를 위해 디스크에 데이터가 쓰이기 전 보관해주는 역할도 한다.

> 4-3. 그런데, 스토리지 엔진이 정확히 무엇을 하는 건가요?


디스크에 데이터를 쓰고 읽는 행위와 그 연관된 모든 행위(Transaction 관리, 락 관리, 인덱싱)를 한다.

## **5. 인덱스가 무엇이고, 언제 사용하는지 설명해 주세요.**

Read 성능을 향상 시키기위해 도입한 방편이다. InnoDB 에서는 pk가 클러스터 형식으로 B+ 트리로 구성된다.

> 5-1. 일반적으로 인덱스는 수정이 잦은 테이블에선 사용하지 않기를 권합니다. 왜 그럴까요?

Read 성능을 향상 시키기위한 트레이드 오프로 수정, 삭제, 삽입시 추가적인 operation 이 필요하다.

> 5-2. ORDER BY/GROUP BY 연산의 동작 과정을 인덱스의 존재여부와 연관지어서 설명해 주세요.
> 

ORDER BY 경우, 정렬 기준 컬럼에 인덱스가 있으면 이미 정렬된 인덱스를 순차적으로 스캔

GROUP BY 경우, GROUP BY 컬럼에 인덱스가 있으면 인덱스 스캔으로 그룹화.

> 5-3. 기본키는 인덱스라고 할 수 있을까요? 그렇지 않다면, 인덱스와 기본키는 어떤 차이가 있나요?
> 

기본키는 각 레코드를 판별하기 위한 도구이고 인덱스는 검색성능을 향상시키기 위한 자료구조 이다.

InnoDB 에서는 기본키가 기본적으로 인덱스로 적용된다. 

> 5-4. 외래키와 인덱스 관계는 어떤가요?
> 

외래키는 단순히 참조 무결성을 보장하는 제약조건입니다. 일반적으로 외래키에 인덱스를 걸어주는 것을 권장합니다. InnoDB 에서는 자동으로 외래키에 인덱스를 생성해준다.

> 5-5. 인덱스가 데이터의 물리적 저장에도 영향을 미치나요? 그렇지 않다면, 데이터는 어떤 순서로 물리적으로 저장되나요?
> 

InnoDB 에서는 영향을 미친다. 기본적으로 pk 기반 클러스터 인덱스를 생성한다. 즉, 디스크에 저장되는 순서가 pk 순으로 저장된다는 뜻이다.

> 5-6. 우리가 아는 RDB가 아닌 NoSQL (ex. Redis, MongoDB 등)는 인덱스를 갖고 있나요? 만약 있다면, RDB의 인덱스와는 어떤 차이가 있을까요?
> 

Redis 는 기본적으로 key-value 형태 자료구조 이므로 인덱스가 필요없다.

MongoDB 의 경우 B-tree 기반 인덱스를 제공한다. TTL, 부분 인덱스 같은 기능을 추가적으로 제공한다.

> 5-7. (A, B) 와 같은 방식으로 인덱스를 설정한 테이블에서, A 조건 없이 B 조건만 사용하여 쿼리를 요청했습니다. 해당 쿼리는 인덱스를 탈까요?
> 

해당 쿼리는 인덱스를 타지 않고 풀스캔 서치를 진행한다.

## **6. RDBMS, NoSQL에서의 클러스터링/레플리케이션 방식에 대해 설명해 주세요.**

Replication

기본적으로 단일 마스터 - 다중 레플리카의 형태를 띈다. 

InnoDB 의 경우 바이너리 로그 파일을 이용하여 비동기 혹은 반동기 방식으로 마스터에 커밋된 데이터를 레플리카들이 가져가게 된다.

Clustering

다중 프라이머리 혹은 단일 프라이머리 방식을 지원한다. 한 노드에서 발생된 변경이 다른 노드에 전파된다. Redis clustering 의 경우 노드들 끼리 gossip protocol 을 통해 소통하며 샤딩과 failover 를 함께 포함하는 개념이다.

> 6-1. 분산 환경에서 트랜잭션을 어떻게 관리할 수 있을까요?
> 
1. 2PC
    
    먼저, 코디네이터가 모든 트랜잭션 참여자에게 트랜잭션이 진행될거라는 신호를 보내고 참여자들은 참여 가능여부를 응답으로 보낸다. 이때, 하나의 참여자라도 참여가 불가능 할경우 트랜잭션을 진행하지 않고 롤백을 한다.
    
2. SAGA 패턴
    
    마이크로서비스 간에 통신을 주고받으며 트랜잭션을 처리.
    
    Choreography 방식은 메세지 브로커를 통해 트랜잭션 보상/실패 이벤트를 주고 받으며 전체 트랜잭션을 진행한다. Orchestration 방식은 매니저가 트랜잭션 진행 상태를 관리한다.
    

> 6-2. 마스터, 슬레이브 데이터 동기화 전 까지의 데이터 정합성을 지키는 방법은 무엇이 있을까요?
> 

절대적인 정합성이 필요하다면, 커밋시에 동기적으로 데이터 정합성을 지켜주면 된다.

> 6-3. 다중 트랜잭션 상황에서의 Deadlock 상황과, 이를 해결하기 위한 방법에 대해 설명해 주세요.
> 

InnoDB 에서는 내부적으로 데드락 감지 알고리즘을 통해 트랜잭션 대기 상태를 검사한다. 만약 순환 대기가 발생하면 롤백에 비용이 적게 드는 트랜잭션을 골라 롤백 시킨다.

> 6-4. 샤딩 방식은 무엇인가요? 만약 본인이 DB를 분산해서 관리해야 한다면, 레플리케이션 방식과 샤딩 방식 중 어떤 것을 사용할 것 같나요?
> 

두 기술은 상황에 따라 따로 써야할수도 있고 동시에 적용해야 할 수도 있습니다. 만약 읽기 성능이 극단적으로 많이 필요한 경우에는 레플리케이션을 우선적으로 고려해 볼 수 있습니다. 그리고, 테이블이 매우 비대해지거나 쓰기 성능이 더 필요한 경우에는 샤딩을 우선 고려해 볼 것 같습니다.

## **7. 정규화가 무엇인가요?**

데이터 무결성을 위해 테이블을 분리하는 것.

제 1정규형 : 하나의 칼럼에는 하나의 값만 들어야 한다.

제 2정규형: 완전 함수 종속을 만족. 기본키의 일부로는 속성이 결정되면 안된다.

제 3정규형: 속성들간 이행 종속성이 없어야 한다. A로 B가 결정되고 B로 C가 결정되면 테이블 분리를 해야한다.

BCNF: 모든 결정자가 후보키여야 한다.  

> 7-1. 정규화를 하지 않을 경우, 발생할 수 있는 이상현상에 대해 설명해 주세요.
> 

삽입 이상 - 필요하지 않은 정보도 삽입해야 하는 경우가 생김

수정 이상 - 중복된 데이터를 수정할때, 일부 데이터만 수정해서 데이터 불일치가 발생

삭제 이상 - 데이터 삭제시 의도하지 않은 정보들도 삭제하게 됨.

> 7-2. 정규화가 무조건 좋은가요? 그렇지 않다면, 어떤 상황에서 역정규화를 하는게 좋은지 설명해 주세요.
> 

읽기 성능을 더 향상시키고 싶은 경우 역정규화를 시킬 수도 있다.

## **8. View가 무엇이고, 언제 사용할 수 있나요?**

view 는 일종의 가상 테이블 역할을 한다. 본질적으로 sql 쿼리문이라고 볼 수 있다. 사용자별 보안 등급이 필요하거나 추상적인 데이터를 제공할 필요가 있을때 주로 사용한다.

> 8-1. 그렇다면, View의 값을 수정해도 실제 테이블에는 반영되지 않나요?
> 

InnoDB 의 경우, 단일 테이블 기반 뷰의 경우에 수정사항이 반영된다.